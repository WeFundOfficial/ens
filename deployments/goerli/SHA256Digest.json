{
  "address": "0xBaFaa666dF96D18Dd9EBA3cc721Ac12F27d2c5a0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "hash",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x1794d2d14d31ebe07495801139534121634a3819f1fc4bce098d870408eb6780",
  "receipt": {
    "to": null,
    "from": "0x81fc7b86316Bb26b4ceC8f38121Bab70b39672F2",
    "contractAddress": "0xBaFaa666dF96D18Dd9EBA3cc721Ac12F27d2c5a0",
    "transactionIndex": 40,
    "gasUsed": "211310",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa047919dd9b97294f3a50670dd20557ebbb1c259c10c91fb11d3346daa7ac139",
    "transactionHash": "0x1794d2d14d31ebe07495801139534121634a3819f1fc4bce098d870408eb6780",
    "logs": [],
    "blockNumber": 9562217,
    "cumulativeGasUsed": "5666620",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "0abd204bc166027a79b4a4534bc42e69",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the DNSSEC SHA256 digest.\",\"kind\":\"dev\",\"methods\":{\"verify(bytes,bytes)\":{\"details\":\"Verifies a cryptographic hash.\",\"params\":{\"data\":\"The data to hash.\",\"hash\":\"The hash to compare to.\"},\"returns\":{\"_0\":\"True iff the hashed data matches the provided hash value.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dnssec-oracle/digests/SHA256Digest.sol\":\"SHA256Digest\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1200},\"remappings\":[]},\"sources\":{\"contracts/dnssec-oracle/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nlibrary BytesUtils {\\r\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the keccak-256 hash of a byte range.\\r\\n     * @param self The byte string to hash.\\r\\n     * @param offset The position to start hashing at.\\r\\n     * @param len The number of bytes to hash.\\r\\n     * @return The hash of the byte range.\\r\\n     */\\r\\n    function keccak(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(offset + len <= self.length);\\r\\n        assembly {\\r\\n            ret := keccak256(add(add(self, 32), offset), len)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (int256) {\\r\\n        return compare(self, 0, self.length, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal. Comparison is done per-rune,\\r\\n     *      on unicode codepoints.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param offset The offset of self.\\r\\n     * @param len    The length of self.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @param otheroffset The offset of the other string.\\r\\n     * @param otherlen    The length of the other string.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len,\\r\\n        bytes memory other,\\r\\n        uint256 otheroffset,\\r\\n        uint256 otherlen\\r\\n    ) internal pure returns (int256) {\\r\\n        if (offset + len > self.length) {\\r\\n            revert OffsetOutOfBoundsError(offset + len, self.length);\\r\\n        }\\r\\n        if (otheroffset + otherlen > other.length) {\\r\\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\\r\\n        }\\r\\n\\r\\n        uint256 shortest = len;\\r\\n        if (otherlen < len) shortest = otherlen;\\r\\n\\r\\n        uint256 selfptr;\\r\\n        uint256 otherptr;\\r\\n\\r\\n        assembly {\\r\\n            selfptr := add(self, add(offset, 32))\\r\\n            otherptr := add(other, add(otheroffset, 32))\\r\\n        }\\r\\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\\r\\n            uint256 a;\\r\\n            uint256 b;\\r\\n            assembly {\\r\\n                a := mload(selfptr)\\r\\n                b := mload(otherptr)\\r\\n            }\\r\\n            if (a != b) {\\r\\n                // Mask out irrelevant bytes and check again\\r\\n                uint256 mask;\\r\\n                if (shortest - idx >= 32) {\\r\\n                    mask = type(uint256).max;\\r\\n                } else {\\r\\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\\r\\n                }\\r\\n                int256 diff = int256(a & mask) - int256(b & mask);\\r\\n                if (diff != 0) return diff;\\r\\n            }\\r\\n            selfptr += 32;\\r\\n            otherptr += 32;\\r\\n        }\\r\\n\\r\\n        return int256(len) - int256(otherlen);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @param len The number of bytes to compare\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bool) {\\r\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal with offsets.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            keccak(self, offset, self.length - offset) ==\\r\\n            keccak(other, otherOffset, other.length - otherOffset);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\\r\\n     *      they are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == offset + other.length &&\\r\\n            equals(self, offset, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == other.length &&\\r\\n            equals(self, 0, other, 0, self.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 8-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 8 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint8(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint8 ret) {\\r\\n        return uint8(self[idx]);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 16-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 16 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint16(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint16 ret) {\\r\\n        require(idx + 2 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint32(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint32 ret) {\\r\\n        require(idx + 4 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes32(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(idx + 32 <= self.length);\\r\\n        assembly {\\r\\n            ret := mload(add(add(self, 32), idx))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes20(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes20 ret) {\\r\\n        require(idx + 20 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(\\r\\n                mload(add(add(self, 32), idx)),\\r\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the n byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes.\\r\\n     * @param len The number of bytes.\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytesN(\\r\\n        bytes memory self,\\r\\n        uint256 idx,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(len <= 32);\\r\\n        require(idx + len <= self.length);\\r\\n        assembly {\\r\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\r\\n            ret := and(mload(add(add(self, 32), idx)), mask)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\\r\\n        // Copy word-length chunks while possible\\r\\n        for (; len >= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        unchecked {\\r\\n            uint256 mask = (256 ** (32 - len)) - 1;\\r\\n            assembly {\\r\\n                let srcpart := and(mload(src), not(mask))\\r\\n                let destpart := and(mload(dest), mask)\\r\\n                mstore(dest, or(destpart, srcpart))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Copies a substring into a new byte string.\\r\\n     * @param self The byte string to copy from.\\r\\n     * @param offset The offset to start copying at.\\r\\n     * @param len The number of bytes to copy.\\r\\n     */\\r\\n    function substring(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        require(offset + len <= self.length);\\r\\n\\r\\n        bytes memory ret = new bytes(len);\\r\\n        uint256 dest;\\r\\n        uint256 src;\\r\\n\\r\\n        assembly {\\r\\n            dest := add(ret, 32)\\r\\n            src := add(add(self, 32), offset)\\r\\n        }\\r\\n        memcpy(dest, src, len);\\r\\n\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\r\\n    // 0xFF represents invalid characters in that range.\\r\\n    bytes constant base32HexTable =\\r\\n        hex\\\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\r\\n     * @param self The data to decode.\\r\\n     * @param off Offset into the string to start at.\\r\\n     * @param len Number of characters to decode.\\r\\n     * @return The decoded data, left aligned.\\r\\n     */\\r\\n    function base32HexDecodeWord(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32) {\\r\\n        require(len <= 52);\\r\\n\\r\\n        uint256 ret = 0;\\r\\n        uint8 decoded;\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            bytes1 char = self[off + i];\\r\\n            require(char >= 0x30 && char <= 0x7A);\\r\\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\\r\\n            require(decoded <= 0x20);\\r\\n            if (i == len - 1) {\\r\\n                break;\\r\\n            }\\r\\n            ret = (ret << 5) | decoded;\\r\\n        }\\r\\n\\r\\n        uint256 bitlen = len * 5;\\r\\n        if (len % 8 == 0) {\\r\\n            // Multiple of 8 characters, no padding\\r\\n            ret = (ret << 5) | decoded;\\r\\n        } else if (len % 8 == 2) {\\r\\n            // Two extra characters - 1 byte\\r\\n            ret = (ret << 3) | (decoded >> 2);\\r\\n            bitlen -= 2;\\r\\n        } else if (len % 8 == 4) {\\r\\n            // Four extra characters - 2 bytes\\r\\n            ret = (ret << 1) | (decoded >> 4);\\r\\n            bitlen -= 4;\\r\\n        } else if (len % 8 == 5) {\\r\\n            // Five extra characters - 3 bytes\\r\\n            ret = (ret << 4) | (decoded >> 1);\\r\\n            bitlen -= 1;\\r\\n        } else if (len % 8 == 7) {\\r\\n            // Seven extra characters - 4 bytes\\r\\n            ret = (ret << 2) | (decoded >> 3);\\r\\n            bitlen -= 3;\\r\\n        } else {\\r\\n            revert();\\r\\n        }\\r\\n\\r\\n        return bytes32(ret << (256 - bitlen));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\\r\\n     * @param self The string to search\\r\\n     * @param off The offset to start searching at\\r\\n     * @param len The number of bytes to search\\r\\n     * @param needle The byte to search for\\r\\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\\r\\n     */\\r\\n    function find(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len,\\r\\n        bytes1 needle\\r\\n    ) internal pure returns (uint256) {\\r\\n        for (uint256 idx = off; idx < off + len; idx++) {\\r\\n            if (self[idx] == needle) {\\r\\n                return idx;\\r\\n            }\\r\\n        }\\r\\n        return type(uint256).max;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x1df10ca3df76235db46f65850d516bf165bcac9514aaa66876a117a3bc93c23b\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/digests/Digest.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev An interface for contracts implementing a DNSSEC digest.\\r\\n */\\r\\ninterface Digest {\\r\\n    /**\\r\\n     * @dev Verifies a cryptographic hash.\\r\\n     * @param data The data to hash.\\r\\n     * @param hash The hash to compare to.\\r\\n     * @return True iff the hashed data matches the provided hash value.\\r\\n     */\\r\\n    function verify(\\r\\n        bytes calldata data,\\r\\n        bytes calldata hash\\r\\n    ) external pure virtual returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x763f01f822751cbf1968f4b195b8c707092d257cd7dfce0fcbb0afa068ee8207\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/digests/SHA256Digest.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./Digest.sol\\\";\\r\\nimport \\\"../BytesUtils.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implements the DNSSEC SHA256 digest.\\r\\n */\\r\\ncontract SHA256Digest is Digest {\\r\\n    using BytesUtils for *;\\r\\n\\r\\n    function verify(\\r\\n        bytes calldata data,\\r\\n        bytes calldata hash\\r\\n    ) external pure override returns (bool) {\\r\\n        require(hash.length == 32, \\\"Invalid sha256 hash length\\\");\\r\\n        return sha256(data) == hash.readBytes32(0);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x2d500f55144fe69f317f79b5f1c5065bb254178244a79fafd3d2270b23003c30\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506102df806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063f7e83aee14610030575b600080fd5b61004361003e3660046101d4565b610057565b604051901515815260200160405180910390f35b6000602082146100c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f496e76616c6964207368613235362068617368206c656e677468000000000000604482015260640160405180910390fd5b61010b600084848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506101679050565b6002868660405161011d929190610240565b602060405180830381855afa15801561013a573d6000803e3d6000fd5b5050506040513d601f19601f8201168201806040525081019061015d9190610250565b1495945050505050565b8151600090610177836020610269565b111561018257600080fd5b50016020015190565b60008083601f84011261019d57600080fd5b50813567ffffffffffffffff8111156101b557600080fd5b6020830191508360208285010111156101cd57600080fd5b9250929050565b600080600080604085870312156101ea57600080fd5b843567ffffffffffffffff8082111561020257600080fd5b61020e8883890161018b565b9096509450602087013591508082111561022757600080fd5b506102348782880161018b565b95989497509550505050565b8183823760009101908152919050565b60006020828403121561026257600080fd5b5051919050565b808201808211156102a3577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220d1b366be02f742efd8164bbd69fab02c0e012aeaf473c8ed5a011b277fa3611464736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063f7e83aee14610030575b600080fd5b61004361003e3660046101d4565b610057565b604051901515815260200160405180910390f35b6000602082146100c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f496e76616c6964207368613235362068617368206c656e677468000000000000604482015260640160405180910390fd5b61010b600084848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506101679050565b6002868660405161011d929190610240565b602060405180830381855afa15801561013a573d6000803e3d6000fd5b5050506040513d601f19601f8201168201806040525081019061015d9190610250565b1495945050505050565b8151600090610177836020610269565b111561018257600080fd5b50016020015190565b60008083601f84011261019d57600080fd5b50813567ffffffffffffffff8111156101b557600080fd5b6020830191508360208285010111156101cd57600080fd5b9250929050565b600080600080604085870312156101ea57600080fd5b843567ffffffffffffffff8082111561020257600080fd5b61020e8883890161018b565b9096509450602087013591508082111561022757600080fd5b506102348782880161018b565b95989497509550505050565b8183823760009101908152919050565b60006020828403121561026257600080fd5b5051919050565b808201808211156102a3577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220d1b366be02f742efd8164bbd69fab02c0e012aeaf473c8ed5a011b277fa3611464736f6c63430008110033",
  "devdoc": {
    "details": "Implements the DNSSEC SHA256 digest.",
    "kind": "dev",
    "methods": {
      "verify(bytes,bytes)": {
        "details": "Verifies a cryptographic hash.",
        "params": {
          "data": "The data to hash.",
          "hash": "The hash to compare to."
        },
        "returns": {
          "_0": "True iff the hashed data matches the provided hash value."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}