{
  "language": "Solidity",
  "sources": {
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "@ensdomains/solsha1/contracts/SHA1.sol": {
      "content": "pragma solidity ^0.8.4;\n\nlibrary SHA1 {\n    event Debug(bytes32 x);\n\n    function sha1(bytes memory data) internal pure returns(bytes20 ret) {\n        assembly {\n            // Get a safe scratch location\n            let scratch := mload(0x40)\n\n            // Get the data length, and point data at the first byte\n            let len := mload(data)\n            data := add(data, 32)\n\n            // Find the length after padding\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\n            switch lt(sub(totallen, len), 9)\n            case 1 { totallen := add(totallen, 64) }\n\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\n\n            function readword(ptr, off, count) -> result {\n                result := 0\n                if lt(off, count) {\n                    result := mload(add(ptr, off))\n                    count := sub(count, off)\n                    if lt(count, 32) {\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\n                        result := and(result, mask)\n                    }\n                }\n            }\n\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\n                mstore(scratch, readword(data, i, len))\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\n\n                // If we loaded the last byte, store the terminator byte\n                switch lt(sub(len, i), 64)\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\n\n                // If this is the last block, store the length\n                switch eq(i, sub(totallen, 64))\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\n\n                // Expand the 16 32-bit words into 80\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\n                    mstore(add(scratch, j), temp)\n                }\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\n                    mstore(add(scratch, j), temp)\n                }\n\n                let x := h\n                let f := 0\n                let k := 0\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\n                    switch div(j, 20)\n                    case 0 {\n                        // f = d xor (b and (c xor d))\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0x5A827999\n                    }\n                    case 1{\n                        // f = b xor c xor d\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0x6ED9EBA1\n                    }\n                    case 2 {\n                        // f = (b and c) or (d and (b or c))\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := and(div(x, 0x10000000000), f)\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\n                        k := 0x8F1BBCDC\n                    }\n                    case 3 {\n                        // f = b xor c xor d\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0xCA62C1D6\n                    }\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\n                    temp := add(f, temp)\n                    temp := add(and(x, 0xFFFFFFFF), temp)\n                    temp := add(k, temp)\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\n                }\n\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\n            }\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/dnsregistrar/DNSClaimChecker.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../dnssec-oracle/DNSSEC.sol\";\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"../dnssec-oracle/RRUtils.sol\";\r\nimport \"../utils/HexUtils.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n\r\nlibrary DNSClaimChecker {\r\n    using BytesUtils for bytes;\r\n    using HexUtils for bytes;\r\n    using RRUtils for *;\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint16 constant CLASS_INET = 1;\r\n    uint16 constant TYPE_TXT = 16;\r\n\r\n    function getOwnerAddress(\r\n        bytes memory name,\r\n        bytes memory data\r\n    ) internal pure returns (address, bool) {\r\n        // Add \"_ens.\" to the front of the name.\r\n        Buffer.buffer memory buf;\r\n        buf.init(name.length + 5);\r\n        buf.append(\"\\x04_ens\");\r\n        buf.append(name);\r\n\r\n        for (\r\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\r\n            !iter.done();\r\n            iter.next()\r\n        ) {\r\n            if (iter.name().compareNames(buf.buf) != 0) continue;\r\n            bool found;\r\n            address addr;\r\n            (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\r\n            if (found) {\r\n                return (addr, true);\r\n            }\r\n        }\r\n\r\n        return (address(0x0), false);\r\n    }\r\n\r\n    function parseRR(\r\n        bytes memory rdata,\r\n        uint256 idx,\r\n        uint256 endIdx\r\n    ) internal pure returns (address, bool) {\r\n        while (idx < endIdx) {\r\n            uint256 len = rdata.readUint8(idx);\r\n            idx += 1;\r\n\r\n            bool found;\r\n            address addr;\r\n            (addr, found) = parseString(rdata, idx, len);\r\n\r\n            if (found) return (addr, true);\r\n            idx += len;\r\n        }\r\n\r\n        return (address(0x0), false);\r\n    }\r\n\r\n    function parseString(\r\n        bytes memory str,\r\n        uint256 idx,\r\n        uint256 len\r\n    ) internal pure returns (address, bool) {\r\n        // TODO: More robust parsing that handles whitespace and multiple key/value pairs\r\n        if (str.readUint32(idx) != 0x613d3078) return (address(0x0), false); // 0x613d3078 == 'a=0x'\r\n        return str.hexToAddress(idx + 4, idx + len);\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/DNSRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"../dnssec-oracle/DNSSEC.sol\";\r\nimport \"../dnssec-oracle/RRUtils.sol\";\r\nimport \"../registry/ENSRegistry.sol\";\r\nimport \"../root/Root.sol\";\r\nimport \"../resolvers/profiles/AddrResolver.sol\";\r\nimport \"./DNSClaimChecker.sol\";\r\nimport \"./PublicSuffixList.sol\";\r\nimport \"./IDNSRegistrar.sol\";\r\n\r\n/**\r\n * @dev An ENS registrar that allows the owner of a DNS name to claim the\r\n *      corresponding name in ENS.\r\n */\r\ncontract DNSRegistrar is IDNSRegistrar, IERC165 {\r\n    using BytesUtils for bytes;\r\n    using Buffer for Buffer.buffer;\r\n    using RRUtils for *;\r\n\r\n    ENS public immutable ens;\r\n    DNSSEC public immutable oracle;\r\n    PublicSuffixList public suffixes;\r\n    address public immutable previousRegistrar;\r\n    address public immutable resolver;\r\n    // A mapping of the most recent signatures seen for each claimed domain.\r\n    mapping(bytes32 => uint32) public inceptions;\r\n\r\n    error NoOwnerRecordFound();\r\n    error PermissionDenied(address caller, address owner);\r\n    error PreconditionNotMet();\r\n    error StaleProof();\r\n    error InvalidPublicSuffix(bytes name);\r\n\r\n    struct OwnerRecord {\r\n        bytes name;\r\n        address owner;\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    event Claim(\r\n        bytes32 indexed node,\r\n        address indexed owner,\r\n        bytes dnsname,\r\n        uint32 inception\r\n    );\r\n    event NewPublicSuffixList(address suffixes);\r\n\r\n    constructor(\r\n        address _previousRegistrar,\r\n        address _resolver,\r\n        DNSSEC _dnssec,\r\n        PublicSuffixList _suffixes,\r\n        ENS _ens\r\n    ) {\r\n        previousRegistrar = _previousRegistrar;\r\n        resolver = _resolver;\r\n        oracle = _dnssec;\r\n        suffixes = _suffixes;\r\n        emit NewPublicSuffixList(address(suffixes));\r\n        ens = _ens;\r\n    }\r\n\r\n    /**\r\n     * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\r\n     */\r\n    modifier onlyOwner() {\r\n        Root root = Root(ens.owner(bytes32(0)));\r\n        address owner = root.owner();\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\r\n        suffixes = _suffixes;\r\n        emit NewPublicSuffixList(address(suffixes));\r\n    }\r\n\r\n    /**\r\n     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\r\n     * @param name The name to claim, in DNS wire format.\r\n     * @param input A chain of signed DNS RRSETs ending with a text record.\r\n     */\r\n    function proveAndClaim(\r\n        bytes memory name,\r\n        DNSSEC.RRSetWithSignature[] memory input\r\n    ) public override {\r\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\r\n            name,\r\n            input\r\n        );\r\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\r\n    }\r\n\r\n    function proveAndClaimWithResolver(\r\n        bytes memory name,\r\n        DNSSEC.RRSetWithSignature[] memory input,\r\n        address resolver,\r\n        address addr\r\n    ) public override {\r\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(\r\n            name,\r\n            input\r\n        );\r\n        if (msg.sender != owner) {\r\n            revert PermissionDenied(msg.sender, owner);\r\n        }\r\n        ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\r\n        if (addr != address(0)) {\r\n            if (resolver == address(0)) {\r\n                revert PreconditionNotMet();\r\n            }\r\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\r\n            // Set the resolver record\r\n            AddrResolver(resolver).setAddr(node, addr);\r\n        }\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) external pure override returns (bool) {\r\n        return\r\n            interfaceID == type(IERC165).interfaceId ||\r\n            interfaceID == type(IDNSRegistrar).interfaceId;\r\n    }\r\n\r\n    function _claim(\r\n        bytes memory name,\r\n        DNSSEC.RRSetWithSignature[] memory input\r\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\r\n        (bytes memory data, uint32 inception) = oracle.verifyRRSet(input);\r\n\r\n        // Get the first label\r\n        uint256 labelLen = name.readUint8(0);\r\n        labelHash = name.keccak(1, labelLen);\r\n\r\n        bytes memory parentName = name.substring(\r\n            labelLen + 1,\r\n            name.length - labelLen - 1\r\n        );\r\n\r\n        // Make sure the parent name is enabled\r\n        parentNode = enableNode(parentName);\r\n\r\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\r\n        if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\r\n            revert StaleProof();\r\n        }\r\n        inceptions[node] = inception;\r\n\r\n        bool found;\r\n        (addr, found) = DNSClaimChecker.getOwnerAddress(name, data);\r\n        if (!found) {\r\n            revert NoOwnerRecordFound();\r\n        }\r\n\r\n        emit Claim(node, addr, name, inception);\r\n    }\r\n\r\n    function enableNode(bytes memory domain) public returns (bytes32 node) {\r\n        // Name must be in the public suffix list.\r\n        if (!suffixes.isPublicSuffix(domain)) {\r\n            revert InvalidPublicSuffix(domain);\r\n        }\r\n        return _enableNode(domain, 0);\r\n    }\r\n\r\n    function _enableNode(\r\n        bytes memory domain,\r\n        uint256 offset\r\n    ) internal returns (bytes32 node) {\r\n        uint256 len = domain.readUint8(offset);\r\n        if (len == 0) {\r\n            return bytes32(0);\r\n        }\r\n\r\n        bytes32 parentNode = _enableNode(domain, offset + len + 1);\r\n        bytes32 label = domain.keccak(offset + 1, len);\r\n        node = keccak256(abi.encodePacked(parentNode, label));\r\n        address owner = ens.owner(node);\r\n        if (owner == address(0) || owner == previousRegistrar) {\r\n            if (parentNode == bytes32(0)) {\r\n                Root root = Root(ens.owner(bytes32(0)));\r\n                root.setSubnodeOwner(label, address(this));\r\n                ens.setResolver(node, resolver);\r\n            } else {\r\n                ens.setSubnodeRecord(\r\n                    parentNode,\r\n                    label,\r\n                    address(this),\r\n                    resolver,\r\n                    0\r\n                );\r\n            }\r\n        } else if (owner != address(this)) {\r\n            revert PreconditionNotMet();\r\n        }\r\n        return node;\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/IDNSRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../dnssec-oracle/DNSSEC.sol\";\r\n\r\ninterface IDNSRegistrar {\r\n    function proveAndClaim(\r\n        bytes memory name,\r\n        DNSSEC.RRSetWithSignature[] memory input\r\n    ) external;\r\n\r\n    function proveAndClaimWithResolver(\r\n        bytes memory name,\r\n        DNSSEC.RRSetWithSignature[] memory input,\r\n        address resolver,\r\n        address addr\r\n    ) external;\r\n}\r\n"
    },
    "contracts/dnsregistrar/OffchainDNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../../contracts/resolvers/profiles/IAddrResolver.sol\";\r\nimport \"../../contracts/resolvers/profiles/IExtendedResolver.sol\";\r\nimport \"../../contracts/resolvers/profiles/IExtendedDNSResolver.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"../dnssec-oracle/DNSSEC.sol\";\r\nimport \"../dnssec-oracle/RRUtils.sol\";\r\nimport \"../registry/ENSRegistry.sol\";\r\nimport \"../utils/HexUtils.sol\";\r\n\r\nerror OffchainLookup(\r\n    address sender,\r\n    string[] urls,\r\n    bytes callData,\r\n    bytes4 callbackFunction,\r\n    bytes extraData\r\n);\r\n\r\ninterface IDNSGateway {\r\n    function resolve(\r\n        bytes memory name,\r\n        uint16 qtype\r\n    ) external returns (DNSSEC.RRSetWithSignature[] memory);\r\n}\r\n\r\nuint16 constant CLASS_INET = 1;\r\nuint16 constant TYPE_TXT = 16;\r\n\r\ncontract OffchainDNSResolver is IExtendedResolver {\r\n    using RRUtils for *;\r\n    using BytesUtils for bytes;\r\n    using HexUtils for bytes;\r\n\r\n    ENS public immutable ens;\r\n    DNSSEC public immutable oracle;\r\n    string public gatewayURL;\r\n\r\n    error CouldNotResolve(bytes name);\r\n\r\n    constructor(ENS _ens, DNSSEC _oracle, string memory _gatewayURL) {\r\n        ens = _ens;\r\n        oracle = _oracle;\r\n        gatewayURL = _gatewayURL;\r\n    }\r\n\r\n    function resolve(\r\n        bytes calldata name,\r\n        bytes calldata data\r\n    ) external view returns (bytes memory) {\r\n        string[] memory urls = new string[](1);\r\n        urls[0] = gatewayURL;\r\n\r\n        revert OffchainLookup(\r\n            address(this),\r\n            urls,\r\n            abi.encodeCall(IDNSGateway.resolve, (name, TYPE_TXT)),\r\n            OffchainDNSResolver.resolveCallback.selector,\r\n            abi.encode(name, data)\r\n        );\r\n    }\r\n\r\n    function resolveCallback(\r\n        bytes calldata response,\r\n        bytes calldata extraData\r\n    ) external view returns (bytes memory) {\r\n        (bytes memory name, bytes memory query) = abi.decode(\r\n            extraData,\r\n            (bytes, bytes)\r\n        );\r\n        DNSSEC.RRSetWithSignature[] memory rrsets = abi.decode(\r\n            response,\r\n            (DNSSEC.RRSetWithSignature[])\r\n        );\r\n\r\n        (bytes memory data, ) = oracle.verifyRRSet(rrsets);\r\n        for (\r\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\r\n            !iter.done();\r\n            iter.next()\r\n        ) {\r\n            // Ignore records with wrong name, type, or class\r\n            bytes memory rrname = RRUtils.readName(iter.data, iter.offset);\r\n            if (\r\n                !rrname.equals(name) ||\r\n                iter.class != CLASS_INET ||\r\n                iter.dnstype != TYPE_TXT\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            // Look for a valid ENS-DNS TXT record\r\n            (address dnsresolver, bytes memory context) = parseRR(\r\n                iter.data,\r\n                iter.rdataOffset,\r\n                iter.nextOffset\r\n            );\r\n\r\n            // If we found a valid record, try to resolve it\r\n            if (dnsresolver != address(0)) {\r\n                if (\r\n                    IERC165(dnsresolver).supportsInterface(\r\n                        IExtendedDNSResolver.resolve.selector\r\n                    )\r\n                ) {\r\n                    return\r\n                        IExtendedDNSResolver(dnsresolver).resolve(\r\n                            name,\r\n                            query,\r\n                            context\r\n                        );\r\n                } else if (\r\n                    IERC165(dnsresolver).supportsInterface(\r\n                        IExtendedResolver.resolve.selector\r\n                    )\r\n                ) {\r\n                    return IExtendedResolver(dnsresolver).resolve(name, query);\r\n                } else {\r\n                    (bool ok, bytes memory ret) = address(dnsresolver)\r\n                        .staticcall(query);\r\n                    if (ok) {\r\n                        return ret;\r\n                    } else {\r\n                        revert CouldNotResolve(name);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // No valid records; revert.\r\n        revert CouldNotResolve(name);\r\n    }\r\n\r\n    function parseRR(\r\n        bytes memory data,\r\n        uint256 idx,\r\n        uint256 lastIdx\r\n    ) internal view returns (address, bytes memory) {\r\n        bytes memory txt = readTXT(data, idx, lastIdx);\r\n\r\n        // Must start with the magic word\r\n        if (txt.length < 5 || !txt.equals(0, \"ENS1 \", 0, 5)) {\r\n            return (address(0), \"\");\r\n        }\r\n\r\n        // Parse the name or address\r\n        uint256 lastTxtIdx = txt.find(5, txt.length - 5, \" \");\r\n        if (lastTxtIdx > txt.length) {\r\n            address dnsResolver = parseAndResolve(txt, 5, txt.length);\r\n            return (dnsResolver, \"\");\r\n        } else {\r\n            address dnsResolver = parseAndResolve(txt, 5, lastTxtIdx);\r\n            return (\r\n                dnsResolver,\r\n                txt.substring(lastTxtIdx + 1, txt.length - lastTxtIdx - 1)\r\n            );\r\n        }\r\n    }\r\n\r\n    function readTXT(\r\n        bytes memory data,\r\n        uint256 startIdx,\r\n        uint256 lastIdx\r\n    ) internal pure returns (bytes memory) {\r\n        // TODO: Concatenate multiple text fields\r\n        uint256 fieldLength = data.readUint8(startIdx);\r\n        assert(startIdx + fieldLength < lastIdx);\r\n        return data.substring(startIdx + 1, fieldLength);\r\n    }\r\n\r\n    function parseAndResolve(\r\n        bytes memory nameOrAddress,\r\n        uint256 idx,\r\n        uint256 lastIdx\r\n    ) internal view returns (address) {\r\n        if (nameOrAddress[idx] == \"0\" && nameOrAddress[idx + 1] == \"x\") {\r\n            (address ret, bool valid) = nameOrAddress.hexToAddress(\r\n                idx + 2,\r\n                lastIdx\r\n            );\r\n            if (valid) {\r\n                return ret;\r\n            }\r\n        }\r\n        return resolveName(nameOrAddress, idx, lastIdx);\r\n    }\r\n\r\n    function resolveName(\r\n        bytes memory name,\r\n        uint256 idx,\r\n        uint256 lastIdx\r\n    ) internal view returns (address) {\r\n        bytes32 node = textNamehash(name, idx, lastIdx);\r\n        address resolver = ens.resolver(node);\r\n        if (resolver == address(0)) {\r\n            return address(0);\r\n        }\r\n        return IAddrResolver(resolver).addr(node);\r\n    }\r\n\r\n    /**\r\n     * @dev Namehash function that operates on dot-separated names (not dns-encoded names)\r\n     * @param name Name to hash\r\n     * @param idx Index to start at\r\n     * @param lastIdx Index to end at\r\n     */\r\n    function textNamehash(\r\n        bytes memory name,\r\n        uint256 idx,\r\n        uint256 lastIdx\r\n    ) internal view returns (bytes32) {\r\n        uint256 separator = name.find(idx, name.length - idx, bytes1(\".\"));\r\n        bytes32 parentNode = bytes32(0);\r\n        if (separator < lastIdx) {\r\n            parentNode = textNamehash(name, separator + 1, lastIdx);\r\n        } else {\r\n            separator = lastIdx;\r\n        }\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(parentNode, name.keccak(idx, separator - idx))\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/PublicSuffixList.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface PublicSuffixList {\r\n    function isPublicSuffix(bytes calldata name) external view returns (bool);\r\n}\r\n"
    },
    "contracts/dnsregistrar/RecordParser.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\n\r\nlibrary RecordParser {\r\n    using BytesUtils for bytes;\r\n\r\n    /**\r\n     * @dev Parses a key-value record into a key and value.\r\n     * @param input The input string\r\n     * @param offset The offset to start reading at\r\n     */\r\n    function readKeyValue(\r\n        bytes memory input,\r\n        uint256 offset,\r\n        uint256 len\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory key, bytes memory value, uint256 nextOffset)\r\n    {\r\n        uint256 separator = input.find(offset, len, \"=\");\r\n        if (separator == type(uint256).max) {\r\n            return (\"\", \"\", type(uint256).max);\r\n        }\r\n\r\n        uint256 terminator = input.find(\r\n            separator,\r\n            len + offset - separator,\r\n            \" \"\r\n        );\r\n        if (terminator == type(uint256).max) {\r\n            terminator = input.length;\r\n        }\r\n\r\n        key = input.substring(offset, separator - offset);\r\n        value = input.substring(separator + 1, terminator - separator - 1);\r\n        nextOffset = terminator + 1;\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/SimplePublicSuffixList.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../root/Ownable.sol\";\r\nimport \"./PublicSuffixList.sol\";\r\n\r\ncontract SimplePublicSuffixList is PublicSuffixList, Ownable {\r\n    mapping(bytes => bool) suffixes;\r\n\r\n    function addPublicSuffixes(bytes[] memory names) public onlyOwner {\r\n        for (uint256 i = 0; i < names.length; i++) {\r\n            suffixes[names[i]] = true;\r\n        }\r\n    }\r\n\r\n    function isPublicSuffix(\r\n        bytes calldata name\r\n    ) external view override returns (bool) {\r\n        return suffixes[name];\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/TLDPublicSuffixList.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"./PublicSuffixList.sol\";\r\n\r\n/**\r\n * @dev A public suffix list that treats all TLDs as public suffixes.\r\n */\r\ncontract TLDPublicSuffixList is PublicSuffixList {\r\n    using BytesUtils for bytes;\r\n\r\n    function isPublicSuffix(\r\n        bytes calldata name\r\n    ) external view override returns (bool) {\r\n        uint256 labellen = name.readUint8(0);\r\n        return labellen > 0 && name.readUint8(labellen + 1) == 0;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/Algorithm.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\r\n */\r\ninterface Algorithm {\r\n    /**\r\n     * @dev Verifies a signature.\r\n     * @param key The public key to verify with.\r\n     * @param data The signed data to verify.\r\n     * @param signature The signature to verify.\r\n     * @return True iff the signature is valid.\r\n     */\r\n    function verify(\r\n        bytes calldata key,\r\n        bytes calldata data,\r\n        bytes calldata signature\r\n    ) external view virtual returns (bool);\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/DummyAlgorithm.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Algorithm.sol\";\r\n\r\n/**\r\n * @dev Implements a dummy DNSSEC (signing) algorithm that approves all\r\n *      signatures, for testing.\r\n */\r\ncontract DummyAlgorithm is Algorithm {\r\n    function verify(\r\n        bytes calldata,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external view override returns (bool) {\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/EllipticCurve.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @title   EllipticCurve\r\n *\r\n * @author  Tilman Drerup;\r\n *\r\n * @notice  Implements elliptic curve math; Parametrized for SECP256R1.\r\n *\r\n *          Includes components of code by Andreas Olofsson, Alexander Vlasov\r\n *          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\r\n *          (https://github.com/orbs-network/elliptic-curve-solidity)\r\n *\r\n *          Source: https://github.com/tdrerup/elliptic-curve-solidity\r\n *\r\n * @dev     NOTE: To disambiguate public keys when verifying signatures, activate\r\n *          condition 'rs[1] > lowSmax' in validateSignature().\r\n */\r\ncontract EllipticCurve {\r\n    // Set parameters for curve.\r\n    uint256 constant a =\r\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\r\n    uint256 constant b =\r\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\r\n    uint256 constant gx =\r\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\r\n    uint256 constant gy =\r\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\r\n    uint256 constant p =\r\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\r\n    uint256 constant n =\r\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\r\n\r\n    uint256 constant lowSmax =\r\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\r\n\r\n    /**\r\n     * @dev Inverse of u in the field of modulo m.\r\n     */\r\n    function inverseMod(uint256 u, uint256 m) internal pure returns (uint256) {\r\n        unchecked {\r\n            if (u == 0 || u == m || m == 0) return 0;\r\n            if (u > m) u = u % m;\r\n\r\n            int256 t1;\r\n            int256 t2 = 1;\r\n            uint256 r1 = m;\r\n            uint256 r2 = u;\r\n            uint256 q;\r\n\r\n            while (r2 != 0) {\r\n                q = r1 / r2;\r\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\r\n            }\r\n\r\n            if (t1 < 0) return (m - uint256(-t1));\r\n\r\n            return uint256(t1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transform affine coordinates into projective coordinates.\r\n     */\r\n    function toProjectivePoint(\r\n        uint256 x0,\r\n        uint256 y0\r\n    ) internal pure returns (uint256[3] memory P) {\r\n        P[2] = addmod(0, 1, p);\r\n        P[0] = mulmod(x0, P[2], p);\r\n        P[1] = mulmod(y0, P[2], p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two points in affine coordinates and return projective point.\r\n     */\r\n    function addAndReturnProjectivePoint(\r\n        uint256 x1,\r\n        uint256 y1,\r\n        uint256 x2,\r\n        uint256 y2\r\n    ) internal pure returns (uint256[3] memory P) {\r\n        uint256 x;\r\n        uint256 y;\r\n        (x, y) = add(x1, y1, x2, y2);\r\n        P = toProjectivePoint(x, y);\r\n    }\r\n\r\n    /**\r\n     * @dev Transform from projective to affine coordinates.\r\n     */\r\n    function toAffinePoint(\r\n        uint256 x0,\r\n        uint256 y0,\r\n        uint256 z0\r\n    ) internal pure returns (uint256 x1, uint256 y1) {\r\n        uint256 z0Inv;\r\n        z0Inv = inverseMod(z0, p);\r\n        x1 = mulmod(x0, z0Inv, p);\r\n        y1 = mulmod(y0, z0Inv, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the zero curve in projective coordinates.\r\n     */\r\n    function zeroProj()\r\n        internal\r\n        pure\r\n        returns (uint256 x, uint256 y, uint256 z)\r\n    {\r\n        return (0, 1, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the zero curve in affine coordinates.\r\n     */\r\n    function zeroAffine() internal pure returns (uint256 x, uint256 y) {\r\n        return (0, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if the curve is the zero curve.\r\n     */\r\n    function isZeroCurve(\r\n        uint256 x0,\r\n        uint256 y0\r\n    ) internal pure returns (bool isZero) {\r\n        if (x0 == 0 && y0 == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a point in affine coordinates is on the curve.\r\n     */\r\n    function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\r\n        if (0 == x || x == p || 0 == y || y == p) {\r\n            return false;\r\n        }\r\n\r\n        uint256 LHS = mulmod(y, y, p); // y^2\r\n        uint256 RHS = mulmod(mulmod(x, x, p), x, p); // x^3\r\n\r\n        if (a != 0) {\r\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\r\n        }\r\n        if (b != 0) {\r\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\r\n        }\r\n\r\n        return LHS == RHS;\r\n    }\r\n\r\n    /**\r\n     * @dev Double an elliptic curve point in projective coordinates. See\r\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\r\n     */\r\n    function twiceProj(\r\n        uint256 x0,\r\n        uint256 y0,\r\n        uint256 z0\r\n    ) internal pure returns (uint256 x1, uint256 y1, uint256 z1) {\r\n        uint256 t;\r\n        uint256 u;\r\n        uint256 v;\r\n        uint256 w;\r\n\r\n        if (isZeroCurve(x0, y0)) {\r\n            return zeroProj();\r\n        }\r\n\r\n        u = mulmod(y0, z0, p);\r\n        u = mulmod(u, 2, p);\r\n\r\n        v = mulmod(u, x0, p);\r\n        v = mulmod(v, y0, p);\r\n        v = mulmod(v, 2, p);\r\n\r\n        x0 = mulmod(x0, x0, p);\r\n        t = mulmod(x0, 3, p);\r\n\r\n        z0 = mulmod(z0, z0, p);\r\n        z0 = mulmod(z0, a, p);\r\n        t = addmod(t, z0, p);\r\n\r\n        w = mulmod(t, t, p);\r\n        x0 = mulmod(2, v, p);\r\n        w = addmod(w, p - x0, p);\r\n\r\n        x0 = addmod(v, p - w, p);\r\n        x0 = mulmod(t, x0, p);\r\n        y0 = mulmod(y0, u, p);\r\n        y0 = mulmod(y0, y0, p);\r\n        y0 = mulmod(2, y0, p);\r\n        y1 = addmod(x0, p - y0, p);\r\n\r\n        x1 = mulmod(u, w, p);\r\n\r\n        z1 = mulmod(u, u, p);\r\n        z1 = mulmod(z1, u, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two elliptic curve points in projective coordinates. See\r\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\r\n     */\r\n    function addProj(\r\n        uint256 x0,\r\n        uint256 y0,\r\n        uint256 z0,\r\n        uint256 x1,\r\n        uint256 y1,\r\n        uint256 z1\r\n    ) internal pure returns (uint256 x2, uint256 y2, uint256 z2) {\r\n        uint256 t0;\r\n        uint256 t1;\r\n        uint256 u0;\r\n        uint256 u1;\r\n\r\n        if (isZeroCurve(x0, y0)) {\r\n            return (x1, y1, z1);\r\n        } else if (isZeroCurve(x1, y1)) {\r\n            return (x0, y0, z0);\r\n        }\r\n\r\n        t0 = mulmod(y0, z1, p);\r\n        t1 = mulmod(y1, z0, p);\r\n\r\n        u0 = mulmod(x0, z1, p);\r\n        u1 = mulmod(x1, z0, p);\r\n\r\n        if (u0 == u1) {\r\n            if (t0 == t1) {\r\n                return twiceProj(x0, y0, z0);\r\n            } else {\r\n                return zeroProj();\r\n            }\r\n        }\r\n\r\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function that splits addProj to avoid too many local variables.\r\n     */\r\n    function addProj2(\r\n        uint256 v,\r\n        uint256 u0,\r\n        uint256 u1,\r\n        uint256 t1,\r\n        uint256 t0\r\n    ) private pure returns (uint256 x2, uint256 y2, uint256 z2) {\r\n        uint256 u;\r\n        uint256 u2;\r\n        uint256 u3;\r\n        uint256 w;\r\n        uint256 t;\r\n\r\n        t = addmod(t0, p - t1, p);\r\n        u = addmod(u0, p - u1, p);\r\n        u2 = mulmod(u, u, p);\r\n\r\n        w = mulmod(t, t, p);\r\n        w = mulmod(w, v, p);\r\n        u1 = addmod(u1, u0, p);\r\n        u1 = mulmod(u1, u2, p);\r\n        w = addmod(w, p - u1, p);\r\n\r\n        x2 = mulmod(u, w, p);\r\n\r\n        u3 = mulmod(u2, u, p);\r\n        u0 = mulmod(u0, u2, p);\r\n        u0 = addmod(u0, p - w, p);\r\n        t = mulmod(t, u0, p);\r\n        t0 = mulmod(t0, u3, p);\r\n\r\n        y2 = addmod(t, p - t0, p);\r\n\r\n        z2 = mulmod(u3, v, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two elliptic curve points in affine coordinates.\r\n     */\r\n    function add(\r\n        uint256 x0,\r\n        uint256 y0,\r\n        uint256 x1,\r\n        uint256 y1\r\n    ) internal pure returns (uint256, uint256) {\r\n        uint256 z0;\r\n\r\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\r\n\r\n        return toAffinePoint(x0, y0, z0);\r\n    }\r\n\r\n    /**\r\n     * @dev Double an elliptic curve point in affine coordinates.\r\n     */\r\n    function twice(\r\n        uint256 x0,\r\n        uint256 y0\r\n    ) internal pure returns (uint256, uint256) {\r\n        uint256 z0;\r\n\r\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\r\n\r\n        return toAffinePoint(x0, y0, z0);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\r\n     */\r\n    function multiplyPowerBase2(\r\n        uint256 x0,\r\n        uint256 y0,\r\n        uint256 exp\r\n    ) internal pure returns (uint256, uint256) {\r\n        uint256 base2X = x0;\r\n        uint256 base2Y = y0;\r\n        uint256 base2Z = 1;\r\n\r\n        for (uint256 i = 0; i < exp; i++) {\r\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\r\n        }\r\n\r\n        return toAffinePoint(base2X, base2Y, base2Z);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an elliptic curve point by a scalar.\r\n     */\r\n    function multiplyScalar(\r\n        uint256 x0,\r\n        uint256 y0,\r\n        uint256 scalar\r\n    ) internal pure returns (uint256 x1, uint256 y1) {\r\n        if (scalar == 0) {\r\n            return zeroAffine();\r\n        } else if (scalar == 1) {\r\n            return (x0, y0);\r\n        } else if (scalar == 2) {\r\n            return twice(x0, y0);\r\n        }\r\n\r\n        uint256 base2X = x0;\r\n        uint256 base2Y = y0;\r\n        uint256 base2Z = 1;\r\n        uint256 z1 = 1;\r\n        x1 = x0;\r\n        y1 = y0;\r\n\r\n        if (scalar % 2 == 0) {\r\n            x1 = y1 = 0;\r\n        }\r\n\r\n        scalar = scalar >> 1;\r\n\r\n        while (scalar > 0) {\r\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\r\n\r\n            if (scalar % 2 == 1) {\r\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\r\n            }\r\n\r\n            scalar = scalar >> 1;\r\n        }\r\n\r\n        return toAffinePoint(x1, y1, z1);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply the curve's generator point by a scalar.\r\n     */\r\n    function multipleGeneratorByScalar(\r\n        uint256 scalar\r\n    ) internal pure returns (uint256, uint256) {\r\n        return multiplyScalar(gx, gy, scalar);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate combination of message, signature, and public key.\r\n     */\r\n    function validateSignature(\r\n        bytes32 message,\r\n        uint256[2] memory rs,\r\n        uint256[2] memory Q\r\n    ) internal pure returns (bool) {\r\n        // To disambiguate between public key solutions, include comment below.\r\n        if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {\r\n            // || rs[1] > lowSmax)\r\n            return false;\r\n        }\r\n        if (!isOnCurve(Q[0], Q[1])) {\r\n            return false;\r\n        }\r\n\r\n        uint256 x1;\r\n        uint256 x2;\r\n        uint256 y1;\r\n        uint256 y2;\r\n\r\n        uint256 sInv = inverseMod(rs[1], n);\r\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\r\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\r\n        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\r\n\r\n        if (P[2] == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 Px = inverseMod(P[2], p);\r\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\r\n\r\n        return Px % n == rs[0];\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nlibrary ModexpPrecompile {\r\n    /**\r\n     * @dev Computes (base ^ exponent) % modulus over big numbers.\r\n     */\r\n    function modexp(\r\n        bytes memory base,\r\n        bytes memory exponent,\r\n        bytes memory modulus\r\n    ) internal view returns (bool success, bytes memory output) {\r\n        bytes memory input = abi.encodePacked(\r\n            uint256(base.length),\r\n            uint256(exponent.length),\r\n            uint256(modulus.length),\r\n            base,\r\n            exponent,\r\n            modulus\r\n        );\r\n\r\n        output = new bytes(modulus.length);\r\n\r\n        assembly {\r\n            success := staticcall(\r\n                gas(),\r\n                5,\r\n                add(input, 32),\r\n                mload(input),\r\n                add(output, 32),\r\n                mload(modulus)\r\n            )\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Algorithm.sol\";\r\nimport \"./EllipticCurve.sol\";\r\nimport \"../BytesUtils.sol\";\r\n\r\ncontract P256SHA256Algorithm is Algorithm, EllipticCurve {\r\n    using BytesUtils for *;\r\n\r\n    /**\r\n     * @dev Verifies a signature.\r\n     * @param key The public key to verify with.\r\n     * @param data The signed data to verify.\r\n     * @param signature The signature to verify.\r\n     * @return True iff the signature is valid.\r\n     */\r\n    function verify(\r\n        bytes calldata key,\r\n        bytes calldata data,\r\n        bytes calldata signature\r\n    ) external view override returns (bool) {\r\n        return\r\n            validateSignature(\r\n                sha256(data),\r\n                parseSignature(signature),\r\n                parseKey(key)\r\n            );\r\n    }\r\n\r\n    function parseSignature(\r\n        bytes memory data\r\n    ) internal pure returns (uint256[2] memory) {\r\n        require(data.length == 64, \"Invalid p256 signature length\");\r\n        return [uint256(data.readBytes32(0)), uint256(data.readBytes32(32))];\r\n    }\r\n\r\n    function parseKey(\r\n        bytes memory data\r\n    ) internal pure returns (uint256[2] memory) {\r\n        require(data.length == 68, \"Invalid p256 key length\");\r\n        return [uint256(data.readBytes32(4)), uint256(data.readBytes32(36))];\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Algorithm.sol\";\r\nimport \"../BytesUtils.sol\";\r\nimport \"./RSAVerify.sol\";\r\nimport \"@ensdomains/solsha1/contracts/SHA1.sol\";\r\n\r\n/**\r\n * @dev Implements the DNSSEC RSASHA1 algorithm.\r\n */\r\ncontract RSASHA1Algorithm is Algorithm {\r\n    using BytesUtils for *;\r\n\r\n    function verify(\r\n        bytes calldata key,\r\n        bytes calldata data,\r\n        bytes calldata sig\r\n    ) external view override returns (bool) {\r\n        bytes memory exponent;\r\n        bytes memory modulus;\r\n\r\n        uint16 exponentLen = uint16(key.readUint8(4));\r\n        if (exponentLen != 0) {\r\n            exponent = key.substring(5, exponentLen);\r\n            modulus = key.substring(\r\n                exponentLen + 5,\r\n                key.length - exponentLen - 5\r\n            );\r\n        } else {\r\n            exponentLen = key.readUint16(5);\r\n            exponent = key.substring(7, exponentLen);\r\n            modulus = key.substring(\r\n                exponentLen + 7,\r\n                key.length - exponentLen - 7\r\n            );\r\n        }\r\n\r\n        // Recover the message from the signature\r\n        bool ok;\r\n        bytes memory result;\r\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\r\n\r\n        // Verify it ends with the hash of our data\r\n        return ok && SHA1.sha1(data) == result.readBytes20(result.length - 20);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/RSASHA256Algorithm.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Algorithm.sol\";\r\nimport \"../BytesUtils.sol\";\r\nimport \"./RSAVerify.sol\";\r\n\r\n/**\r\n * @dev Implements the DNSSEC RSASHA256 algorithm.\r\n */\r\ncontract RSASHA256Algorithm is Algorithm {\r\n    using BytesUtils for *;\r\n\r\n    function verify(\r\n        bytes calldata key,\r\n        bytes calldata data,\r\n        bytes calldata sig\r\n    ) external view override returns (bool) {\r\n        bytes memory exponent;\r\n        bytes memory modulus;\r\n\r\n        uint16 exponentLen = uint16(key.readUint8(4));\r\n        if (exponentLen != 0) {\r\n            exponent = key.substring(5, exponentLen);\r\n            modulus = key.substring(\r\n                exponentLen + 5,\r\n                key.length - exponentLen - 5\r\n            );\r\n        } else {\r\n            exponentLen = key.readUint16(5);\r\n            exponent = key.substring(7, exponentLen);\r\n            modulus = key.substring(\r\n                exponentLen + 7,\r\n                key.length - exponentLen - 7\r\n            );\r\n        }\r\n\r\n        // Recover the message from the signature\r\n        bool ok;\r\n        bytes memory result;\r\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\r\n\r\n        // Verify it ends with the hash of our data\r\n        return ok && sha256(data) == result.readBytes32(result.length - 32);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/RSAVerify.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../BytesUtils.sol\";\r\nimport \"./ModexpPrecompile.sol\";\r\n\r\nlibrary RSAVerify {\r\n    /**\r\n     * @dev Recovers the input data from an RSA signature, returning the result in S.\r\n     * @param N The RSA public modulus.\r\n     * @param E The RSA public exponent.\r\n     * @param S The signature to recover.\r\n     * @return True if the recovery succeeded.\r\n     */\r\n    function rsarecover(\r\n        bytes memory N,\r\n        bytes memory E,\r\n        bytes memory S\r\n    ) internal view returns (bool, bytes memory) {\r\n        return ModexpPrecompile.modexp(S, E, N);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/BytesUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nlibrary BytesUtils {\r\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of a byte range.\r\n     * @param self The byte string to hash.\r\n     * @param offset The position to start hashing at.\r\n     * @param len The number of bytes to hash.\r\n     * @return The hash of the byte range.\r\n     */\r\n    function keccak(\r\n        bytes memory self,\r\n        uint256 offset,\r\n        uint256 len\r\n    ) internal pure returns (bytes32 ret) {\r\n        require(offset + len <= self.length);\r\n        assembly {\r\n            ret := keccak256(add(add(self, 32), offset), len)\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two bytes are equal.\r\n     * @param self The first bytes to compare.\r\n     * @param other The second bytes to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(\r\n        bytes memory self,\r\n        bytes memory other\r\n    ) internal pure returns (int256) {\r\n        return compare(self, 0, self.length, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two bytes are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first bytes to compare.\r\n     * @param offset The offset of self.\r\n     * @param len    The length of self.\r\n     * @param other The second bytes to compare.\r\n     * @param otheroffset The offset of the other string.\r\n     * @param otherlen    The length of the other string.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(\r\n        bytes memory self,\r\n        uint256 offset,\r\n        uint256 len,\r\n        bytes memory other,\r\n        uint256 otheroffset,\r\n        uint256 otherlen\r\n    ) internal pure returns (int256) {\r\n        if (offset + len > self.length) {\r\n            revert OffsetOutOfBoundsError(offset + len, self.length);\r\n        }\r\n        if (otheroffset + otherlen > other.length) {\r\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\r\n        }\r\n\r\n        uint256 shortest = len;\r\n        if (otherlen < len) shortest = otherlen;\r\n\r\n        uint256 selfptr;\r\n        uint256 otherptr;\r\n\r\n        assembly {\r\n            selfptr := add(self, add(offset, 32))\r\n            otherptr := add(other, add(otheroffset, 32))\r\n        }\r\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\r\n            uint256 a;\r\n            uint256 b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask;\r\n                if (shortest - idx >= 32) {\r\n                    mask = type(uint256).max;\r\n                } else {\r\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\r\n                }\r\n                int256 diff = int256(a & mask) - int256(b & mask);\r\n                if (diff != 0) return diff;\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n\r\n        return int256(len) - int256(otherlen);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two byte ranges are equal.\r\n     * @param self The first byte range to compare.\r\n     * @param offset The offset into the first byte range.\r\n     * @param other The second byte range to compare.\r\n     * @param otherOffset The offset into the second byte range.\r\n     * @param len The number of bytes to compare\r\n     * @return True if the byte ranges are equal, false otherwise.\r\n     */\r\n    function equals(\r\n        bytes memory self,\r\n        uint256 offset,\r\n        bytes memory other,\r\n        uint256 otherOffset,\r\n        uint256 len\r\n    ) internal pure returns (bool) {\r\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two byte ranges are equal with offsets.\r\n     * @param self The first byte range to compare.\r\n     * @param offset The offset into the first byte range.\r\n     * @param other The second byte range to compare.\r\n     * @param otherOffset The offset into the second byte range.\r\n     * @return True if the byte ranges are equal, false otherwise.\r\n     */\r\n    function equals(\r\n        bytes memory self,\r\n        uint256 offset,\r\n        bytes memory other,\r\n        uint256 otherOffset\r\n    ) internal pure returns (bool) {\r\n        return\r\n            keccak(self, offset, self.length - offset) ==\r\n            keccak(other, otherOffset, other.length - otherOffset);\r\n    }\r\n\r\n    /*\r\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\r\n     *      they are equal.\r\n     * @param self The first byte range to compare.\r\n     * @param offset The offset into the first byte range.\r\n     * @param other The second byte range to compare.\r\n     * @return True if the byte ranges are equal, false otherwise.\r\n     */\r\n    function equals(\r\n        bytes memory self,\r\n        uint256 offset,\r\n        bytes memory other\r\n    ) internal pure returns (bool) {\r\n        return\r\n            self.length == offset + other.length &&\r\n            equals(self, offset, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two byte ranges are equal.\r\n     * @param self The first byte range to compare.\r\n     * @param other The second byte range to compare.\r\n     * @return True if the byte ranges are equal, false otherwise.\r\n     */\r\n    function equals(\r\n        bytes memory self,\r\n        bytes memory other\r\n    ) internal pure returns (bool) {\r\n        return\r\n            self.length == other.length &&\r\n            equals(self, 0, other, 0, self.length);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the 8-bit number at the specified index of self.\r\n     * @param self The byte string.\r\n     * @param idx The index into the bytes\r\n     * @return The specified 8 bits of the string, interpreted as an integer.\r\n     */\r\n    function readUint8(\r\n        bytes memory self,\r\n        uint256 idx\r\n    ) internal pure returns (uint8 ret) {\r\n        return uint8(self[idx]);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the 16-bit number at the specified index of self.\r\n     * @param self The byte string.\r\n     * @param idx The index into the bytes\r\n     * @return The specified 16 bits of the string, interpreted as an integer.\r\n     */\r\n    function readUint16(\r\n        bytes memory self,\r\n        uint256 idx\r\n    ) internal pure returns (uint16 ret) {\r\n        require(idx + 2 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the 32-bit number at the specified index of self.\r\n     * @param self The byte string.\r\n     * @param idx The index into the bytes\r\n     * @return The specified 32 bits of the string, interpreted as an integer.\r\n     */\r\n    function readUint32(\r\n        bytes memory self,\r\n        uint256 idx\r\n    ) internal pure returns (uint32 ret) {\r\n        require(idx + 4 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the 32 byte value at the specified index of self.\r\n     * @param self The byte string.\r\n     * @param idx The index into the bytes\r\n     * @return The specified 32 bytes of the string.\r\n     */\r\n    function readBytes32(\r\n        bytes memory self,\r\n        uint256 idx\r\n    ) internal pure returns (bytes32 ret) {\r\n        require(idx + 32 <= self.length);\r\n        assembly {\r\n            ret := mload(add(add(self, 32), idx))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the 32 byte value at the specified index of self.\r\n     * @param self The byte string.\r\n     * @param idx The index into the bytes\r\n     * @return The specified 32 bytes of the string.\r\n     */\r\n    function readBytes20(\r\n        bytes memory self,\r\n        uint256 idx\r\n    ) internal pure returns (bytes20 ret) {\r\n        require(idx + 20 <= self.length);\r\n        assembly {\r\n            ret := and(\r\n                mload(add(add(self, 32), idx)),\r\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\r\n            )\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the n byte value at the specified index of self.\r\n     * @param self The byte string.\r\n     * @param idx The index into the bytes.\r\n     * @param len The number of bytes.\r\n     * @return The specified 32 bytes of the string.\r\n     */\r\n    function readBytesN(\r\n        bytes memory self,\r\n        uint256 idx,\r\n        uint256 len\r\n    ) internal pure returns (bytes32 ret) {\r\n        require(len <= 32);\r\n        require(idx + len <= self.length);\r\n        assembly {\r\n            let mask := not(sub(exp(256, sub(32, len)), 1))\r\n            ret := and(mload(add(add(self, 32), idx)), mask)\r\n        }\r\n    }\r\n\r\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        unchecked {\r\n            uint256 mask = (256 ** (32 - len)) - 1;\r\n            assembly {\r\n                let srcpart := and(mload(src), not(mask))\r\n                let destpart := and(mload(dest), mask)\r\n                mstore(dest, or(destpart, srcpart))\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a substring into a new byte string.\r\n     * @param self The byte string to copy from.\r\n     * @param offset The offset to start copying at.\r\n     * @param len The number of bytes to copy.\r\n     */\r\n    function substring(\r\n        bytes memory self,\r\n        uint256 offset,\r\n        uint256 len\r\n    ) internal pure returns (bytes memory) {\r\n        require(offset + len <= self.length);\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint256 dest;\r\n        uint256 src;\r\n\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n\r\n    // Maps characters from 0x30 to 0x7A to their base32 values.\r\n    // 0xFF represents invalid characters in that range.\r\n    bytes constant base32HexTable =\r\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\r\n\r\n    /**\r\n     * @dev Decodes unpadded base32 data of up to one word in length.\r\n     * @param self The data to decode.\r\n     * @param off Offset into the string to start at.\r\n     * @param len Number of characters to decode.\r\n     * @return The decoded data, left aligned.\r\n     */\r\n    function base32HexDecodeWord(\r\n        bytes memory self,\r\n        uint256 off,\r\n        uint256 len\r\n    ) internal pure returns (bytes32) {\r\n        require(len <= 52);\r\n\r\n        uint256 ret = 0;\r\n        uint8 decoded;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            bytes1 char = self[off + i];\r\n            require(char >= 0x30 && char <= 0x7A);\r\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\r\n            require(decoded <= 0x20);\r\n            if (i == len - 1) {\r\n                break;\r\n            }\r\n            ret = (ret << 5) | decoded;\r\n        }\r\n\r\n        uint256 bitlen = len * 5;\r\n        if (len % 8 == 0) {\r\n            // Multiple of 8 characters, no padding\r\n            ret = (ret << 5) | decoded;\r\n        } else if (len % 8 == 2) {\r\n            // Two extra characters - 1 byte\r\n            ret = (ret << 3) | (decoded >> 2);\r\n            bitlen -= 2;\r\n        } else if (len % 8 == 4) {\r\n            // Four extra characters - 2 bytes\r\n            ret = (ret << 1) | (decoded >> 4);\r\n            bitlen -= 4;\r\n        } else if (len % 8 == 5) {\r\n            // Five extra characters - 3 bytes\r\n            ret = (ret << 4) | (decoded >> 1);\r\n            bitlen -= 1;\r\n        } else if (len % 8 == 7) {\r\n            // Seven extra characters - 4 bytes\r\n            ret = (ret << 2) | (decoded >> 3);\r\n            bitlen -= 3;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        return bytes32(ret << (256 - bitlen));\r\n    }\r\n\r\n    /**\r\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\r\n     * @param self The string to search\r\n     * @param off The offset to start searching at\r\n     * @param len The number of bytes to search\r\n     * @param needle The byte to search for\r\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\r\n     */\r\n    function find(\r\n        bytes memory self,\r\n        uint256 off,\r\n        uint256 len,\r\n        bytes1 needle\r\n    ) internal pure returns (uint256) {\r\n        for (uint256 idx = off; idx < off + len; idx++) {\r\n            if (self[idx] == needle) {\r\n                return idx;\r\n            }\r\n        }\r\n        return type(uint256).max;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/digests/Digest.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev An interface for contracts implementing a DNSSEC digest.\r\n */\r\ninterface Digest {\r\n    /**\r\n     * @dev Verifies a cryptographic hash.\r\n     * @param data The data to hash.\r\n     * @param hash The hash to compare to.\r\n     * @return True iff the hashed data matches the provided hash value.\r\n     */\r\n    function verify(\r\n        bytes calldata data,\r\n        bytes calldata hash\r\n    ) external pure virtual returns (bool);\r\n}\r\n"
    },
    "contracts/dnssec-oracle/digests/DummyDigest.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Digest.sol\";\r\n\r\n/**\r\n * @dev Implements a dummy DNSSEC digest that approves all hashes, for testing.\r\n */\r\ncontract DummyDigest is Digest {\r\n    function verify(\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external pure override returns (bool) {\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/digests/SHA1Digest.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Digest.sol\";\r\nimport \"../BytesUtils.sol\";\r\nimport \"@ensdomains/solsha1/contracts/SHA1.sol\";\r\n\r\n/**\r\n * @dev Implements the DNSSEC SHA1 digest.\r\n */\r\ncontract SHA1Digest is Digest {\r\n    using BytesUtils for *;\r\n\r\n    function verify(\r\n        bytes calldata data,\r\n        bytes calldata hash\r\n    ) external pure override returns (bool) {\r\n        require(hash.length == 20, \"Invalid sha1 hash length\");\r\n        bytes32 expected = hash.readBytes20(0);\r\n        bytes20 computed = SHA1.sha1(data);\r\n        return expected == computed;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/digests/SHA256Digest.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Digest.sol\";\r\nimport \"../BytesUtils.sol\";\r\n\r\n/**\r\n * @dev Implements the DNSSEC SHA256 digest.\r\n */\r\ncontract SHA256Digest is Digest {\r\n    using BytesUtils for *;\r\n\r\n    function verify(\r\n        bytes calldata data,\r\n        bytes calldata hash\r\n    ) external pure override returns (bool) {\r\n        require(hash.length == 32, \"Invalid sha256 hash length\");\r\n        return sha256(data) == hash.readBytes32(0);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/DNSSEC.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nabstract contract DNSSEC {\r\n    bytes public anchors;\r\n\r\n    struct RRSetWithSignature {\r\n        bytes rrset;\r\n        bytes sig;\r\n    }\r\n\r\n    event AlgorithmUpdated(uint8 id, address addr);\r\n    event DigestUpdated(uint8 id, address addr);\r\n\r\n    function verifyRRSet(\r\n        RRSetWithSignature[] memory input\r\n    ) external view virtual returns (bytes memory rrs, uint32 inception);\r\n\r\n    function verifyRRSet(\r\n        RRSetWithSignature[] memory input,\r\n        uint256 now\r\n    ) public view virtual returns (bytes memory rrs, uint32 inception);\r\n}\r\n"
    },
    "contracts/dnssec-oracle/DNSSECImpl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./Owned.sol\";\r\nimport \"./BytesUtils.sol\";\r\nimport \"./RRUtils.sol\";\r\nimport \"./DNSSEC.sol\";\r\nimport \"./algorithms/Algorithm.sol\";\r\nimport \"./digests/Digest.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n\r\n/*\r\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\r\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\r\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\r\n *       - Proofs involving wildcard names will not validate.\r\n *       - TTLs on records are ignored, as data is not stored persistently.\r\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\r\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\r\n */\r\ncontract DNSSECImpl is DNSSEC, Owned {\r\n    using Buffer for Buffer.buffer;\r\n    using BytesUtils for bytes;\r\n    using RRUtils for *;\r\n\r\n    uint16 constant DNSCLASS_IN = 1;\r\n\r\n    uint16 constant DNSTYPE_DS = 43;\r\n    uint16 constant DNSTYPE_DNSKEY = 48;\r\n\r\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\r\n\r\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\r\n    error SignatureNotValidYet(uint32 inception, uint32 now);\r\n    error SignatureExpired(uint32 expiration, uint32 now);\r\n    error InvalidClass(uint16 class);\r\n    error InvalidRRSet();\r\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\r\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\r\n    error InvalidProofType(uint16 proofType);\r\n    error ProofNameMismatch(bytes signerName, bytes proofName);\r\n    error NoMatchingProof(bytes signerName);\r\n\r\n    mapping(uint8 => Algorithm) public algorithms;\r\n    mapping(uint8 => Digest) public digests;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _anchors The binary format RR entries for the root DS records.\r\n     */\r\n    constructor(bytes memory _anchors) {\r\n        // Insert the 'trust anchors' - the key hashes that start the chain\r\n        // of trust for all other records.\r\n        anchors = _anchors;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the contract address for a signature verification algorithm.\r\n     *      Callable only by the owner.\r\n     * @param id The algorithm ID\r\n     * @param algo The address of the algorithm contract.\r\n     */\r\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\r\n        algorithms[id] = algo;\r\n        emit AlgorithmUpdated(id, address(algo));\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the contract address for a digest verification algorithm.\r\n     *      Callable only by the owner.\r\n     * @param id The digest ID\r\n     * @param digest The address of the digest contract.\r\n     */\r\n    function setDigest(uint8 id, Digest digest) public owner_only {\r\n        digests[id] = digest;\r\n        emit DigestUpdated(id, address(digest));\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\r\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\r\n     * @param input A list of signed RRSets.\r\n     * @return rrs The RRData from the last RRSet in the chain.\r\n     * @return inception The inception time of the signed record set.\r\n     */\r\n    function verifyRRSet(\r\n        RRSetWithSignature[] memory input\r\n    )\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (bytes memory rrs, uint32 inception)\r\n    {\r\n        return verifyRRSet(input, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\r\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\r\n     * @param input A list of signed RRSets.\r\n     * @param now The Unix timestamp to validate the records at.\r\n     * @return rrs The RRData from the last RRSet in the chain.\r\n     * @return inception The inception time of the signed record set.\r\n     */\r\n    function verifyRRSet(\r\n        RRSetWithSignature[] memory input,\r\n        uint256 now\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bytes memory rrs, uint32 inception)\r\n    {\r\n        bytes memory proof = anchors;\r\n        for (uint256 i = 0; i < input.length; i++) {\r\n            RRUtils.SignedSet memory rrset = validateSignedSet(\r\n                input[i],\r\n                proof,\r\n                now\r\n            );\r\n            proof = rrset.data;\r\n            inception = rrset.inception;\r\n        }\r\n        return (proof, inception);\r\n    }\r\n\r\n    /**\r\n     * @dev Validates an RRSet against the already trusted RR provided in `proof`.\r\n     *\r\n     * @param input The signed RR set. This is in the format described in section\r\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\r\n     *        data, followed by a series of canonicalised RR records that the signature\r\n     *        applies to.\r\n     * @param proof The DNSKEY or DS to validate the signature against.\r\n     * @param now The current timestamp.\r\n     */\r\n    function validateSignedSet(\r\n        RRSetWithSignature memory input,\r\n        bytes memory proof,\r\n        uint256 now\r\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\r\n        rrset = input.rrset.readSignedSet();\r\n\r\n        // Do some basic checks on the RRs and extract the name\r\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\r\n        if (name.labelCount(0) != rrset.labels) {\r\n            revert InvalidLabelCount(name, rrset.labels);\r\n        }\r\n        rrset.name = name;\r\n\r\n        // All comparisons involving the Signature Expiration and\r\n        // Inception fields MUST use \"serial number arithmetic\", as\r\n        // defined in RFC 1982\r\n\r\n        // o  The validator's notion of the current time MUST be less than or\r\n        //    equal to the time listed in the RRSIG RR's Expiration field.\r\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\r\n            revert SignatureExpired(rrset.expiration, uint32(now));\r\n        }\r\n\r\n        // o  The validator's notion of the current time MUST be greater than or\r\n        //    equal to the time listed in the RRSIG RR's Inception field.\r\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\r\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\r\n        }\r\n\r\n        // Validate the signature\r\n        verifySignature(name, rrset, input, proof);\r\n\r\n        return rrset;\r\n    }\r\n\r\n    /**\r\n     * @dev Validates a set of RRs.\r\n     * @param rrset The RR set.\r\n     * @param typecovered The type covered by the RRSIG record.\r\n     */\r\n    function validateRRs(\r\n        RRUtils.SignedSet memory rrset,\r\n        uint16 typecovered\r\n    ) internal pure returns (bytes memory name) {\r\n        // Iterate over all the RRs\r\n        for (\r\n            RRUtils.RRIterator memory iter = rrset.rrs();\r\n            !iter.done();\r\n            iter.next()\r\n        ) {\r\n            // We only support class IN (Internet)\r\n            if (iter.class != DNSCLASS_IN) {\r\n                revert InvalidClass(iter.class);\r\n            }\r\n\r\n            if (name.length == 0) {\r\n                name = iter.name();\r\n            } else {\r\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\r\n                // repeatedly.\r\n                if (\r\n                    name.length != iter.data.nameLength(iter.offset) ||\r\n                    !name.equals(0, iter.data, iter.offset, name.length)\r\n                ) {\r\n                    revert InvalidRRSet();\r\n                }\r\n            }\r\n\r\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\r\n            if (iter.dnstype != typecovered) {\r\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs signature verification.\r\n     *\r\n     * Throws or reverts if unable to verify the record.\r\n     *\r\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\r\n     * @param data The original data to verify.\r\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\r\n     */\r\n    function verifySignature(\r\n        bytes memory name,\r\n        RRUtils.SignedSet memory rrset,\r\n        RRSetWithSignature memory data,\r\n        bytes memory proof\r\n    ) internal view {\r\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\r\n        //    that contains the RRset.\r\n        if (!name.isSubdomainOf(rrset.signerName)) {\r\n            revert InvalidSignerName(name, rrset.signerName);\r\n        }\r\n\r\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\r\n        // Check the proof\r\n        if (proofRR.dnstype == DNSTYPE_DS) {\r\n            verifyWithDS(rrset, data, proofRR);\r\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\r\n            verifyWithKnownKey(rrset, data, proofRR);\r\n        } else {\r\n            revert InvalidProofType(proofRR.dnstype);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a signed RRSET against an already known public key.\r\n     * @param rrset The signed set to verify.\r\n     * @param data The original data the signed set was read from.\r\n     * @param proof The serialized DS or DNSKEY record to use as proof.\r\n     */\r\n    function verifyWithKnownKey(\r\n        RRUtils.SignedSet memory rrset,\r\n        RRSetWithSignature memory data,\r\n        RRUtils.RRIterator memory proof\r\n    ) internal view {\r\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\r\n        for (; !proof.done(); proof.next()) {\r\n            bytes memory proofName = proof.name();\r\n            if (!proofName.equals(rrset.signerName)) {\r\n                revert ProofNameMismatch(rrset.signerName, proofName);\r\n            }\r\n\r\n            bytes memory keyrdata = proof.rdata();\r\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\r\n                0,\r\n                keyrdata.length\r\n            );\r\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\r\n                return;\r\n            }\r\n        }\r\n        revert NoMatchingProof(rrset.signerName);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify some data using a provided key and a signature.\r\n     * @param dnskey The dns key record to verify the signature with.\r\n     * @param rrset The signed RRSET being verified.\r\n     * @param data The original data `rrset` was decoded from.\r\n     * @return True iff the key verifies the signature.\r\n     */\r\n    function verifySignatureWithKey(\r\n        RRUtils.DNSKEY memory dnskey,\r\n        bytes memory keyrdata,\r\n        RRUtils.SignedSet memory rrset,\r\n        RRSetWithSignature memory data\r\n    ) internal view returns (bool) {\r\n        // TODO: Check key isn't expired, unless updating key itself\r\n\r\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\r\n        if (dnskey.protocol != 3) {\r\n            return false;\r\n        }\r\n\r\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\r\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\r\n        //   the zone's apex DNSKEY RRset.\r\n        if (dnskey.algorithm != rrset.algorithm) {\r\n            return false;\r\n        }\r\n        uint16 computedkeytag = keyrdata.computeKeytag();\r\n        if (computedkeytag != rrset.keytag) {\r\n            return false;\r\n        }\r\n\r\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\r\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\r\n        //   set.\r\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\r\n            return false;\r\n        }\r\n\r\n        Algorithm algorithm = algorithms[dnskey.algorithm];\r\n        if (address(algorithm) == address(0)) {\r\n            return false;\r\n        }\r\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\r\n     *      that the record\r\n     * @param rrset The signed set to verify.\r\n     * @param data The original data the signed set was read from.\r\n     * @param proof The serialized DS or DNSKEY record to use as proof.\r\n     */\r\n    function verifyWithDS(\r\n        RRUtils.SignedSet memory rrset,\r\n        RRSetWithSignature memory data,\r\n        RRUtils.RRIterator memory proof\r\n    ) internal view {\r\n        uint256 proofOffset = proof.offset;\r\n        for (\r\n            RRUtils.RRIterator memory iter = rrset.rrs();\r\n            !iter.done();\r\n            iter.next()\r\n        ) {\r\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\r\n                revert InvalidProofType(iter.dnstype);\r\n            }\r\n\r\n            bytes memory keyrdata = iter.rdata();\r\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\r\n                0,\r\n                keyrdata.length\r\n            );\r\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\r\n                // It's self-signed - look for a DS record to verify it.\r\n                if (\r\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\r\n                ) {\r\n                    return;\r\n                }\r\n                // Rewind proof iterator to the start for the next loop iteration.\r\n                proof.nextOffset = proofOffset;\r\n                proof.next();\r\n            }\r\n        }\r\n        revert NoMatchingProof(rrset.signerName);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a key using DS records.\r\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\r\n     * @param dsrrs The DS records to use in verification.\r\n     * @param dnskey The dnskey to verify.\r\n     * @param keyrdata The RDATA section of the key.\r\n     * @return True if a DS record verifies this key.\r\n     */\r\n    function verifyKeyWithDS(\r\n        bytes memory keyname,\r\n        RRUtils.RRIterator memory dsrrs,\r\n        RRUtils.DNSKEY memory dnskey,\r\n        bytes memory keyrdata\r\n    ) internal view returns (bool) {\r\n        uint16 keytag = keyrdata.computeKeytag();\r\n        for (; !dsrrs.done(); dsrrs.next()) {\r\n            bytes memory proofName = dsrrs.name();\r\n            if (!proofName.equals(keyname)) {\r\n                revert ProofNameMismatch(keyname, proofName);\r\n            }\r\n\r\n            RRUtils.DS memory ds = dsrrs.data.readDS(\r\n                dsrrs.rdataOffset,\r\n                dsrrs.nextOffset - dsrrs.rdataOffset\r\n            );\r\n            if (ds.keytag != keytag) {\r\n                continue;\r\n            }\r\n            if (ds.algorithm != dnskey.algorithm) {\r\n                continue;\r\n            }\r\n\r\n            Buffer.buffer memory buf;\r\n            buf.init(keyname.length + keyrdata.length);\r\n            buf.append(keyname);\r\n            buf.append(keyrdata);\r\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a DS record's hash value against some data.\r\n     * @param digesttype The digest ID from the DS record.\r\n     * @param data The data to digest.\r\n     * @param digest The digest data to check against.\r\n     * @return True iff the digest matches.\r\n     */\r\n    function verifyDSHash(\r\n        uint8 digesttype,\r\n        bytes memory data,\r\n        bytes memory digest\r\n    ) internal view returns (bool) {\r\n        if (address(digests[digesttype]) == address(0)) {\r\n            return false;\r\n        }\r\n        return digests[digesttype].verify(data, digest);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/Owned.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Contract mixin for 'owned' contracts.\r\n */\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    modifier owner_only() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address newOwner) public owner_only {\r\n        owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/RRUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./BytesUtils.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n\r\n/**\r\n * @dev RRUtils is a library that provides utilities for parsing DNS resource records.\r\n */\r\nlibrary RRUtils {\r\n    using BytesUtils for *;\r\n    using Buffer for *;\r\n\r\n    /**\r\n     * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\r\n     * @param self The byte array to read a name from.\r\n     * @param offset The offset to start reading at.\r\n     * @return The length of the DNS name at 'offset', in bytes.\r\n     */\r\n    function nameLength(\r\n        bytes memory self,\r\n        uint256 offset\r\n    ) internal pure returns (uint256) {\r\n        uint256 idx = offset;\r\n        while (true) {\r\n            assert(idx < self.length);\r\n            uint256 labelLen = self.readUint8(idx);\r\n            idx += labelLen + 1;\r\n            if (labelLen == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return idx - offset;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a DNS format name at the specified offset of self.\r\n     * @param self The byte array to read a name from.\r\n     * @param offset The offset to start reading at.\r\n     * @return ret The name.\r\n     */\r\n    function readName(\r\n        bytes memory self,\r\n        uint256 offset\r\n    ) internal pure returns (bytes memory ret) {\r\n        uint256 len = nameLength(self, offset);\r\n        return self.substring(offset, len);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\r\n     * @param self The byte array to read a name from.\r\n     * @param offset The offset to start reading at.\r\n     * @return The number of labels in the DNS name at 'offset', in bytes.\r\n     */\r\n    function labelCount(\r\n        bytes memory self,\r\n        uint256 offset\r\n    ) internal pure returns (uint256) {\r\n        uint256 count = 0;\r\n        while (true) {\r\n            assert(offset < self.length);\r\n            uint256 labelLen = self.readUint8(offset);\r\n            offset += labelLen + 1;\r\n            if (labelLen == 0) {\r\n                break;\r\n            }\r\n            count += 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    uint256 constant RRSIG_TYPE = 0;\r\n    uint256 constant RRSIG_ALGORITHM = 2;\r\n    uint256 constant RRSIG_LABELS = 3;\r\n    uint256 constant RRSIG_TTL = 4;\r\n    uint256 constant RRSIG_EXPIRATION = 8;\r\n    uint256 constant RRSIG_INCEPTION = 12;\r\n    uint256 constant RRSIG_KEY_TAG = 16;\r\n    uint256 constant RRSIG_SIGNER_NAME = 18;\r\n\r\n    struct SignedSet {\r\n        uint16 typeCovered;\r\n        uint8 algorithm;\r\n        uint8 labels;\r\n        uint32 ttl;\r\n        uint32 expiration;\r\n        uint32 inception;\r\n        uint16 keytag;\r\n        bytes signerName;\r\n        bytes data;\r\n        bytes name;\r\n    }\r\n\r\n    function readSignedSet(\r\n        bytes memory data\r\n    ) internal pure returns (SignedSet memory self) {\r\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\r\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\r\n        self.labels = data.readUint8(RRSIG_LABELS);\r\n        self.ttl = data.readUint32(RRSIG_TTL);\r\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\r\n        self.inception = data.readUint32(RRSIG_INCEPTION);\r\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\r\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\r\n        self.data = data.substring(\r\n            RRSIG_SIGNER_NAME + self.signerName.length,\r\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\r\n        );\r\n    }\r\n\r\n    function rrs(\r\n        SignedSet memory rrset\r\n    ) internal pure returns (RRIterator memory) {\r\n        return iterateRRs(rrset.data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev An iterator over resource records.\r\n     */\r\n    struct RRIterator {\r\n        bytes data;\r\n        uint256 offset;\r\n        uint16 dnstype;\r\n        uint16 class;\r\n        uint32 ttl;\r\n        uint256 rdataOffset;\r\n        uint256 nextOffset;\r\n    }\r\n\r\n    /**\r\n     * @dev Begins iterating over resource records.\r\n     * @param self The byte string to read from.\r\n     * @param offset The offset to start reading at.\r\n     * @return ret An iterator object.\r\n     */\r\n    function iterateRRs(\r\n        bytes memory self,\r\n        uint256 offset\r\n    ) internal pure returns (RRIterator memory ret) {\r\n        ret.data = self;\r\n        ret.nextOffset = offset;\r\n        next(ret);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true iff there are more RRs to iterate.\r\n     * @param iter The iterator to check.\r\n     * @return True iff the iterator has finished.\r\n     */\r\n    function done(RRIterator memory iter) internal pure returns (bool) {\r\n        return iter.offset >= iter.data.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves the iterator to the next resource record.\r\n     * @param iter The iterator to advance.\r\n     */\r\n    function next(RRIterator memory iter) internal pure {\r\n        iter.offset = iter.nextOffset;\r\n        if (iter.offset >= iter.data.length) {\r\n            return;\r\n        }\r\n\r\n        // Skip the name\r\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\r\n\r\n        // Read type, class, and ttl\r\n        iter.dnstype = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.class = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.ttl = iter.data.readUint32(off);\r\n        off += 4;\r\n\r\n        // Read the rdata\r\n        uint256 rdataLength = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.rdataOffset = off;\r\n        iter.nextOffset = off + rdataLength;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the current record.\r\n     * @param iter The iterator.\r\n     * @return A new bytes object containing the owner name from the RR.\r\n     */\r\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\r\n        return\r\n            iter.data.substring(\r\n                iter.offset,\r\n                nameLength(iter.data, iter.offset)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rdata portion of the current record.\r\n     * @param iter The iterator.\r\n     * @return A new bytes object containing the RR's RDATA.\r\n     */\r\n    function rdata(\r\n        RRIterator memory iter\r\n    ) internal pure returns (bytes memory) {\r\n        return\r\n            iter.data.substring(\r\n                iter.rdataOffset,\r\n                iter.nextOffset - iter.rdataOffset\r\n            );\r\n    }\r\n\r\n    uint256 constant DNSKEY_FLAGS = 0;\r\n    uint256 constant DNSKEY_PROTOCOL = 2;\r\n    uint256 constant DNSKEY_ALGORITHM = 3;\r\n    uint256 constant DNSKEY_PUBKEY = 4;\r\n\r\n    struct DNSKEY {\r\n        uint16 flags;\r\n        uint8 protocol;\r\n        uint8 algorithm;\r\n        bytes publicKey;\r\n    }\r\n\r\n    function readDNSKEY(\r\n        bytes memory data,\r\n        uint256 offset,\r\n        uint256 length\r\n    ) internal pure returns (DNSKEY memory self) {\r\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\r\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\r\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\r\n        self.publicKey = data.substring(\r\n            offset + DNSKEY_PUBKEY,\r\n            length - DNSKEY_PUBKEY\r\n        );\r\n    }\r\n\r\n    uint256 constant DS_KEY_TAG = 0;\r\n    uint256 constant DS_ALGORITHM = 2;\r\n    uint256 constant DS_DIGEST_TYPE = 3;\r\n    uint256 constant DS_DIGEST = 4;\r\n\r\n    struct DS {\r\n        uint16 keytag;\r\n        uint8 algorithm;\r\n        uint8 digestType;\r\n        bytes digest;\r\n    }\r\n\r\n    function readDS(\r\n        bytes memory data,\r\n        uint256 offset,\r\n        uint256 length\r\n    ) internal pure returns (DS memory self) {\r\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\r\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\r\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\r\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\r\n    }\r\n\r\n    function isSubdomainOf(\r\n        bytes memory self,\r\n        bytes memory other\r\n    ) internal pure returns (bool) {\r\n        uint256 off = 0;\r\n        uint256 counts = labelCount(self, 0);\r\n        uint256 othercounts = labelCount(other, 0);\r\n\r\n        while (counts > othercounts) {\r\n            off = progress(self, off);\r\n            counts--;\r\n        }\r\n\r\n        return self.equals(off, other, 0);\r\n    }\r\n\r\n    function compareNames(\r\n        bytes memory self,\r\n        bytes memory other\r\n    ) internal pure returns (int256) {\r\n        if (self.equals(other)) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 off;\r\n        uint256 otheroff;\r\n        uint256 prevoff;\r\n        uint256 otherprevoff;\r\n        uint256 counts = labelCount(self, 0);\r\n        uint256 othercounts = labelCount(other, 0);\r\n\r\n        // Keep removing labels from the front of the name until both names are equal length\r\n        while (counts > othercounts) {\r\n            prevoff = off;\r\n            off = progress(self, off);\r\n            counts--;\r\n        }\r\n\r\n        while (othercounts > counts) {\r\n            otherprevoff = otheroff;\r\n            otheroff = progress(other, otheroff);\r\n            othercounts--;\r\n        }\r\n\r\n        // Compare the last nonequal labels to each other\r\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\r\n            prevoff = off;\r\n            off = progress(self, off);\r\n            otherprevoff = otheroff;\r\n            otheroff = progress(other, otheroff);\r\n            counts -= 1;\r\n        }\r\n\r\n        if (off == 0) {\r\n            return -1;\r\n        }\r\n        if (otheroff == 0) {\r\n            return 1;\r\n        }\r\n\r\n        return\r\n            self.compare(\r\n                prevoff + 1,\r\n                self.readUint8(prevoff),\r\n                other,\r\n                otherprevoff + 1,\r\n                other.readUint8(otherprevoff)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Compares two serial numbers using RFC1982 serial number math.\r\n     */\r\n    function serialNumberGte(\r\n        uint32 i1,\r\n        uint32 i2\r\n    ) internal pure returns (bool) {\r\n        unchecked {\r\n            return int32(i1) - int32(i2) >= 0;\r\n        }\r\n    }\r\n\r\n    function progress(\r\n        bytes memory body,\r\n        uint256 off\r\n    ) internal pure returns (uint256) {\r\n        return off + 1 + body.readUint8(off);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the keytag for a chunk of data.\r\n     * @param data The data to compute a keytag for.\r\n     * @return The computed key tag.\r\n     */\r\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\r\n        /* This function probably deserves some explanation.\r\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\r\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\r\n         *\r\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\r\n         *         uint ac;\r\n         *         for (uint i = 0; i < data.length; i++) {\r\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\r\n         *         }\r\n         *         return uint16(ac + (ac >> 16));\r\n         *     }\r\n         *\r\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\r\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\r\n         * large words work in our favour.\r\n         *\r\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\r\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\r\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\r\n         * effectively summing 16 different numbers with each EVM ADD opcode.\r\n         *\r\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\r\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\r\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\r\n         * and the remaining sums can be done just on ac1.\r\n         */\r\n        unchecked {\r\n            require(data.length <= 8192, \"Long keys not permitted\");\r\n            uint256 ac1;\r\n            uint256 ac2;\r\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\r\n                uint256 word;\r\n                assembly {\r\n                    word := mload(add(add(data, 32), i))\r\n                }\r\n                if (i + 32 > data.length) {\r\n                    uint256 unused = 256 - (data.length - i) * 8;\r\n                    word = (word >> unused) << unused;\r\n                }\r\n                ac1 +=\r\n                    (word &\r\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\r\n                    8;\r\n                ac2 += (word &\r\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\r\n            }\r\n            ac1 =\r\n                (ac1 &\r\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\r\n                ((ac1 &\r\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\r\n                    16);\r\n            ac2 =\r\n                (ac2 &\r\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\r\n                ((ac2 &\r\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\r\n                    16);\r\n            ac1 = (ac1 << 8) + ac2;\r\n            ac1 =\r\n                (ac1 &\r\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\r\n                ((ac1 &\r\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\r\n                    32);\r\n            ac1 =\r\n                (ac1 &\r\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\r\n                ((ac1 &\r\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\r\n                    64);\r\n            ac1 =\r\n                (ac1 &\r\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\r\n                (ac1 >> 128);\r\n            ac1 += (ac1 >> 16) & 0xFFFF;\r\n            return uint16(ac1);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/SHA1.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nlibrary SHA1 {\r\n    event Debug(bytes32 x);\r\n\r\n    function sha1(bytes memory data) internal pure returns (bytes20 ret) {\r\n        assembly {\r\n            // Get a safe scratch location\r\n            let scratch := mload(0x40)\r\n\r\n            // Get the data length, and point data at the first byte\r\n            let len := mload(data)\r\n            data := add(data, 32)\r\n\r\n            // Find the length after padding\r\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\r\n            switch lt(sub(totallen, len), 9)\r\n            case 1 {\r\n                totallen := add(totallen, 64)\r\n            }\r\n\r\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\r\n\r\n            function readword(ptr, off, count) -> result {\r\n                result := 0\r\n                if lt(off, count) {\r\n                    result := mload(add(ptr, off))\r\n                    count := sub(count, off)\r\n                    if lt(count, 32) {\r\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\r\n                        result := and(result, mask)\r\n                    }\r\n                }\r\n            }\r\n\r\n            for {\r\n                let i := 0\r\n            } lt(i, totallen) {\r\n                i := add(i, 64)\r\n            } {\r\n                mstore(scratch, readword(data, i, len))\r\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\r\n\r\n                // If we loaded the last byte, store the terminator byte\r\n                switch lt(sub(len, i), 64)\r\n                case 1 {\r\n                    mstore8(add(scratch, sub(len, i)), 0x80)\r\n                }\r\n\r\n                // If this is the last block, store the length\r\n                switch eq(i, sub(totallen, 64))\r\n                case 1 {\r\n                    mstore(\r\n                        add(scratch, 32),\r\n                        or(mload(add(scratch, 32)), mul(len, 8))\r\n                    )\r\n                }\r\n\r\n                // Expand the 16 32-bit words into 80\r\n                for {\r\n                    let j := 64\r\n                } lt(j, 128) {\r\n                    j := add(j, 12)\r\n                } {\r\n                    let temp := xor(\r\n                        xor(\r\n                            mload(add(scratch, sub(j, 12))),\r\n                            mload(add(scratch, sub(j, 32)))\r\n                        ),\r\n                        xor(\r\n                            mload(add(scratch, sub(j, 56))),\r\n                            mload(add(scratch, sub(j, 64)))\r\n                        )\r\n                    )\r\n                    temp := or(\r\n                        and(\r\n                            mul(temp, 2),\r\n                            0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE\r\n                        ),\r\n                        and(\r\n                            div(temp, 0x80000000),\r\n                            0x0000000100000001000000010000000100000001000000010000000100000001\r\n                        )\r\n                    )\r\n                    mstore(add(scratch, j), temp)\r\n                }\r\n                for {\r\n                    let j := 128\r\n                } lt(j, 320) {\r\n                    j := add(j, 24)\r\n                } {\r\n                    let temp := xor(\r\n                        xor(\r\n                            mload(add(scratch, sub(j, 24))),\r\n                            mload(add(scratch, sub(j, 64)))\r\n                        ),\r\n                        xor(\r\n                            mload(add(scratch, sub(j, 112))),\r\n                            mload(add(scratch, sub(j, 128)))\r\n                        )\r\n                    )\r\n                    temp := or(\r\n                        and(\r\n                            mul(temp, 4),\r\n                            0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC\r\n                        ),\r\n                        and(\r\n                            div(temp, 0x40000000),\r\n                            0x0000000300000003000000030000000300000003000000030000000300000003\r\n                        )\r\n                    )\r\n                    mstore(add(scratch, j), temp)\r\n                }\r\n\r\n                let x := h\r\n                let f := 0\r\n                let k := 0\r\n                for {\r\n                    let j := 0\r\n                } lt(j, 80) {\r\n                    j := add(j, 1)\r\n                } {\r\n                    switch div(j, 20)\r\n                    case 0 {\r\n                        // f = d xor (b and (c xor d))\r\n                        f := xor(\r\n                            div(x, 0x100000000000000000000),\r\n                            div(x, 0x10000000000)\r\n                        )\r\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0x5A827999\r\n                    }\r\n                    case 1 {\r\n                        // f = b xor c xor d\r\n                        f := xor(\r\n                            div(x, 0x1000000000000000000000000000000),\r\n                            div(x, 0x100000000000000000000)\r\n                        )\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0x6ED9EBA1\r\n                    }\r\n                    case 2 {\r\n                        // f = (b and c) or (d and (b or c))\r\n                        f := or(\r\n                            div(x, 0x1000000000000000000000000000000),\r\n                            div(x, 0x100000000000000000000)\r\n                        )\r\n                        f := and(div(x, 0x10000000000), f)\r\n                        f := or(\r\n                            and(\r\n                                div(x, 0x1000000000000000000000000000000),\r\n                                div(x, 0x100000000000000000000)\r\n                            ),\r\n                            f\r\n                        )\r\n                        k := 0x8F1BBCDC\r\n                    }\r\n                    case 3 {\r\n                        // f = b xor c xor d\r\n                        f := xor(\r\n                            div(x, 0x1000000000000000000000000000000),\r\n                            div(x, 0x100000000000000000000)\r\n                        )\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0xCA62C1D6\r\n                    }\r\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\r\n                    let temp := and(\r\n                        div(\r\n                            x,\r\n                            0x80000000000000000000000000000000000000000000000\r\n                        ),\r\n                        0x1F\r\n                    )\r\n                    temp := or(\r\n                        and(\r\n                            div(x, 0x800000000000000000000000000000000000000),\r\n                            0xFFFFFFE0\r\n                        ),\r\n                        temp\r\n                    )\r\n                    temp := add(f, temp)\r\n                    temp := add(and(x, 0xFFFFFFFF), temp)\r\n                    temp := add(k, temp)\r\n                    temp := add(\r\n                        div(\r\n                            mload(add(scratch, mul(j, 4))),\r\n                            0x100000000000000000000000000000000000000000000000000000000\r\n                        ),\r\n                        temp\r\n                    )\r\n                    x := or(\r\n                        div(x, 0x10000000000),\r\n                        mul(temp, 0x10000000000000000000000000000000000000000)\r\n                    )\r\n                    x := or(\r\n                        and(\r\n                            x,\r\n                            0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF\r\n                        ),\r\n                        mul(\r\n                            or(\r\n                                and(div(x, 0x4000000000000), 0xC0000000),\r\n                                and(div(x, 0x400000000000000000000), 0x3FFFFFFF)\r\n                            ),\r\n                            0x100000000000000000000\r\n                        )\r\n                    )\r\n                }\r\n\r\n                h := and(\r\n                    add(h, x),\r\n                    0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF\r\n                )\r\n            }\r\n            ret := mul(\r\n                or(\r\n                    or(\r\n                        or(\r\n                            or(\r\n                                and(\r\n                                    div(h, 0x100000000),\r\n                                    0xFFFFFFFF00000000000000000000000000000000\r\n                                ),\r\n                                and(\r\n                                    div(h, 0x1000000),\r\n                                    0xFFFFFFFF000000000000000000000000\r\n                                )\r\n                            ),\r\n                            and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)\r\n                        ),\r\n                        and(div(h, 0x100), 0xFFFFFFFF00000000)\r\n                    ),\r\n                    and(h, 0xFFFFFFFF)\r\n                ),\r\n                0x1000000000000000000000000\r\n            )\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/IBaseRegistrar.sol": {
      "content": "import \"../registry/ENS.sol\";\r\nimport \"./IBaseRegistrar.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\ninterface IBaseRegistrar is IERC721 {\r\n    event ControllerAdded(address indexed controller);\r\n    event ControllerRemoved(address indexed controller);\r\n    event NameMigrated(\r\n        uint256 indexed id,\r\n        address indexed owner,\r\n        uint256 expires\r\n    );\r\n    event NameRegistered(\r\n        uint256 indexed id,\r\n        address indexed owner,\r\n        uint256 expires\r\n    );\r\n    event NameRenewed(uint256 indexed id, uint256 expires);\r\n\r\n    // Authorises a controller, who can register and renew domains.\r\n    function addController(address controller) external;\r\n\r\n    // Revoke controller permission for an address.\r\n    function removeController(address controller) external;\r\n\r\n    // Set the resolver for the TLD this registrar manages.\r\n    function setResolver(address resolver) external;\r\n\r\n    // Returns the expiration timestamp of the specified label hash.\r\n    function nameExpires(uint256 id) external view returns (uint256);\r\n\r\n    // Returns true if the specified name is available for registration.\r\n    function available(uint256 id) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Register a name.\r\n     */\r\n    function register(\r\n        uint256 id,\r\n        address owner,\r\n        uint256 duration\r\n    ) external returns (uint256);\r\n\r\n    function renew(uint256 id, uint256 duration) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\r\n     */\r\n    function reclaim(uint256 id, address owner) external;\r\n}\r\n"
    },
    "contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ninterface ENS {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function setRecord(\r\n        bytes32 node,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeRecord(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeOwner(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner\r\n    ) external returns (bytes32);\r\n\r\n    function setResolver(bytes32 node, address resolver) external;\r\n\r\n    function setOwner(bytes32 node, address owner) external;\r\n\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function owner(bytes32 node) external view returns (address);\r\n\r\n    function resolver(bytes32 node) external view returns (address);\r\n\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n    function recordExists(bytes32 node) external view returns (bool);\r\n\r\n    function isApprovedForAll(\r\n        address owner,\r\n        address operator\r\n    ) external view returns (bool);\r\n}\r\n"
    },
    "contracts/registry/ENSRegistry.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./ENS.sol\";\r\n\r\n/**\r\n * The ENS registry contract.\r\n */\r\ncontract ENSRegistry is ENS {\r\n    struct Record {\r\n        address owner;\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    mapping(bytes32 => Record) records;\r\n    mapping(address => mapping(address => bool)) operators;\r\n\r\n    // Permits modifications only by the owner of the specified node.\r\n    modifier authorised(bytes32 node) {\r\n        address owner = records[node].owner;\r\n        require(owner == msg.sender || operators[owner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructs a new ENS registry.\r\n     */\r\n    constructor() public {\r\n        records[0x0].owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the record for a node.\r\n     * @param node The node to update.\r\n     * @param owner The address of the new owner.\r\n     * @param resolver The address of the resolver.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setRecord(\r\n        bytes32 node,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external virtual override {\r\n        setOwner(node, owner);\r\n        _setResolverAndTTL(node, resolver, ttl);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the record for a subnode.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     * @param resolver The address of the resolver.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setSubnodeRecord(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external virtual override {\r\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\r\n        _setResolverAndTTL(subnode, resolver, ttl);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\r\n     * @param node The node to transfer ownership of.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setOwner(\r\n        bytes32 node,\r\n        address owner\r\n    ) public virtual override authorised(node) {\r\n        _setOwner(node, owner);\r\n        emit Transfer(node, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setSubnodeOwner(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner\r\n    ) public virtual override authorised(node) returns (bytes32) {\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\r\n        _setOwner(subnode, owner);\r\n        emit NewOwner(node, label, owner);\r\n        return subnode;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the resolver address for the specified node.\r\n     * @param node The node to update.\r\n     * @param resolver The address of the resolver.\r\n     */\r\n    function setResolver(\r\n        bytes32 node,\r\n        address resolver\r\n    ) public virtual override authorised(node) {\r\n        emit NewResolver(node, resolver);\r\n        records[node].resolver = resolver;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the TTL for the specified node.\r\n     * @param node The node to update.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setTTL(\r\n        bytes32 node,\r\n        uint64 ttl\r\n    ) public virtual override authorised(node) {\r\n        emit NewTTL(node, ttl);\r\n        records[node].ttl = ttl;\r\n    }\r\n\r\n    /**\r\n     * @dev Enable or disable approval for a third party (\"operator\") to manage\r\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\r\n     * @param operator Address to add to the set of authorized operators.\r\n     * @param approved True if the operator is approved, false to revoke approval.\r\n     */\r\n    function setApprovalForAll(\r\n        address operator,\r\n        bool approved\r\n    ) external virtual override {\r\n        operators[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that owns the specified node.\r\n     * @param node The specified node.\r\n     * @return address of the owner.\r\n     */\r\n    function owner(\r\n        bytes32 node\r\n    ) public view virtual override returns (address) {\r\n        address addr = records[node].owner;\r\n        if (addr == address(this)) {\r\n            return address(0x0);\r\n        }\r\n\r\n        return addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the resolver for the specified node.\r\n     * @param node The specified node.\r\n     * @return address of the resolver.\r\n     */\r\n    function resolver(\r\n        bytes32 node\r\n    ) public view virtual override returns (address) {\r\n        return records[node].resolver;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the TTL of a node, and any records associated with it.\r\n     * @param node The specified node.\r\n     * @return ttl of the node.\r\n     */\r\n    function ttl(bytes32 node) public view virtual override returns (uint64) {\r\n        return records[node].ttl;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a record has been imported to the registry.\r\n     * @param node The specified node.\r\n     * @return Bool if record exists\r\n     */\r\n    function recordExists(\r\n        bytes32 node\r\n    ) public view virtual override returns (bool) {\r\n        return records[node].owner != address(0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Query if an address is an authorized operator for another address.\r\n     * @param owner The address that owns the records.\r\n     * @param operator The address that acts on behalf of the owner.\r\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\r\n     */\r\n    function isApprovedForAll(\r\n        address owner,\r\n        address operator\r\n    ) external view virtual override returns (bool) {\r\n        return operators[owner][operator];\r\n    }\r\n\r\n    function _setOwner(bytes32 node, address owner) internal virtual {\r\n        records[node].owner = owner;\r\n    }\r\n\r\n    function _setResolverAndTTL(\r\n        bytes32 node,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) internal {\r\n        if (resolver != records[node].resolver) {\r\n            records[node].resolver = resolver;\r\n            emit NewResolver(node, resolver);\r\n        }\r\n\r\n        if (ttl != records[node].ttl) {\r\n            records[node].ttl = ttl;\r\n            emit NewTTL(node, ttl);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/IMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IMulticallable {\r\n    function multicall(\r\n        bytes[] calldata data\r\n    ) external returns (bytes[] memory results);\r\n\r\n    function multicallWithNodeCheck(\r\n        bytes32,\r\n        bytes[] calldata data\r\n    ) external returns (bytes[] memory results);\r\n}\r\n"
    },
    "contracts/resolvers/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./IMulticallable.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\n\r\nabstract contract Multicallable is IMulticallable, ERC165 {\r\n    function _multicall(\r\n        bytes32 nodehash,\r\n        bytes[] calldata data\r\n    ) internal returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            if (nodehash != bytes32(0)) {\r\n                bytes32 txNamehash = bytes32(data[i][4:36]);\r\n                require(\r\n                    txNamehash == nodehash,\r\n                    \"multicall: All records must have a matching namehash\"\r\n                );\r\n            }\r\n            (bool success, bytes memory result) = address(this).delegatecall(\r\n                data[i]\r\n            );\r\n            require(success);\r\n            results[i] = result;\r\n        }\r\n        return results;\r\n    }\r\n\r\n    // This function provides an extra security check when called\r\n    // from priviledged contracts (such as EthRegistrarController)\r\n    // that can set records on behalf of the node owners\r\n    function multicallWithNodeCheck(\r\n        bytes32 nodehash,\r\n        bytes[] calldata data\r\n    ) external returns (bytes[] memory results) {\r\n        return _multicall(nodehash, data);\r\n    }\r\n\r\n    function multicall(\r\n        bytes[] calldata data\r\n    ) public override returns (bytes[] memory results) {\r\n        return _multicall(bytes32(0), data);\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(IMulticallable).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/OwnedResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./profiles/ABIResolver.sol\";\r\nimport \"./profiles/AddrResolver.sol\";\r\nimport \"./profiles/ContentHashResolver.sol\";\r\nimport \"./profiles/DNSResolver.sol\";\r\nimport \"./profiles/InterfaceResolver.sol\";\r\nimport \"./profiles/NameResolver.sol\";\r\nimport \"./profiles/PubkeyResolver.sol\";\r\nimport \"./profiles/TextResolver.sol\";\r\nimport \"./profiles/ExtendedResolver.sol\";\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract OwnedResolver is\r\n    Ownable,\r\n    ABIResolver,\r\n    AddrResolver,\r\n    ContentHashResolver,\r\n    DNSResolver,\r\n    InterfaceResolver,\r\n    NameResolver,\r\n    PubkeyResolver,\r\n    TextResolver,\r\n    ExtendedResolver\r\n{\r\n    function isAuthorised(bytes32) internal view override returns (bool) {\r\n        return msg.sender == owner();\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(\r\n            ABIResolver,\r\n            AddrResolver,\r\n            ContentHashResolver,\r\n            DNSResolver,\r\n            InterfaceResolver,\r\n            NameResolver,\r\n            PubkeyResolver,\r\n            TextResolver\r\n        )\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/ABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"./IABIResolver.sol\";\r\nimport \"../ResolverBase.sol\";\r\n\r\nabstract contract ABIResolver is IABIResolver, ResolverBase {\r\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_abis;\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(\r\n        bytes32 node,\r\n        uint256 contentType,\r\n        bytes calldata data\r\n    ) external virtual authorised(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n\r\n        versionable_abis[recordVersions[node]][node][contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(\r\n        bytes32 node,\r\n        uint256 contentTypes\r\n    ) external view virtual override returns (uint256, bytes memory) {\r\n        mapping(uint256 => bytes) storage abiset = versionable_abis[\r\n            recordVersions[node]\r\n        ][node];\r\n\r\n        for (\r\n            uint256 contentType = 1;\r\n            contentType <= contentTypes;\r\n            contentType <<= 1\r\n        ) {\r\n            if (\r\n                (contentType & contentTypes) != 0 &&\r\n                abiset[contentType].length > 0\r\n            ) {\r\n                return (contentType, abiset[contentType]);\r\n            }\r\n        }\r\n\r\n        return (0, bytes(\"\"));\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(IABIResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/AddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"../ResolverBase.sol\";\r\nimport \"./IAddrResolver.sol\";\r\nimport \"./IAddressResolver.sol\";\r\n\r\nabstract contract AddrResolver is\r\n    IAddrResolver,\r\n    IAddressResolver,\r\n    ResolverBase\r\n{\r\n    uint256 private constant COIN_TYPE_ETH = 60;\r\n\r\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param a The address to set.\r\n     */\r\n    function setAddr(\r\n        bytes32 node,\r\n        address a\r\n    ) external virtual authorised(node) {\r\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(\r\n        bytes32 node\r\n    ) public view virtual override returns (address payable) {\r\n        bytes memory a = addr(node, COIN_TYPE_ETH);\r\n        if (a.length == 0) {\r\n            return payable(0);\r\n        }\r\n        return bytesToAddress(a);\r\n    }\r\n\r\n    function setAddr(\r\n        bytes32 node,\r\n        uint256 coinType,\r\n        bytes memory a\r\n    ) public virtual authorised(node) {\r\n        emit AddressChanged(node, coinType, a);\r\n        if (coinType == COIN_TYPE_ETH) {\r\n            emit AddrChanged(node, bytesToAddress(a));\r\n        }\r\n        versionable_addresses[recordVersions[node]][node][coinType] = a;\r\n    }\r\n\r\n    function addr(\r\n        bytes32 node,\r\n        uint256 coinType\r\n    ) public view virtual override returns (bytes memory) {\r\n        return versionable_addresses[recordVersions[node]][node][coinType];\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(IAddrResolver).interfaceId ||\r\n            interfaceID == type(IAddressResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n\r\n    function bytesToAddress(\r\n        bytes memory b\r\n    ) internal pure returns (address payable a) {\r\n        require(b.length == 20);\r\n        assembly {\r\n            a := div(mload(add(b, 32)), exp(256, 12))\r\n        }\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\r\n        b = new bytes(20);\r\n        assembly {\r\n            mstore(add(b, 32), mul(a, exp(256, 12)))\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/ContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"../ResolverBase.sol\";\r\nimport \"./IContentHashResolver.sol\";\r\n\r\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\r\n    mapping(uint64 => mapping(bytes32 => bytes)) versionable_hashes;\r\n\r\n    /**\r\n     * Sets the contenthash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The contenthash to set\r\n     */\r\n    function setContenthash(\r\n        bytes32 node,\r\n        bytes calldata hash\r\n    ) external virtual authorised(node) {\r\n        versionable_hashes[recordVersions[node]][node] = hash;\r\n        emit ContenthashChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(\r\n        bytes32 node\r\n    ) external view virtual override returns (bytes memory) {\r\n        return versionable_hashes[recordVersions[node]][node];\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(IContentHashResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/DNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"../ResolverBase.sol\";\r\nimport \"../../dnssec-oracle/RRUtils.sol\";\r\nimport \"./IDNSRecordResolver.sol\";\r\nimport \"./IDNSZoneResolver.sol\";\r\n\r\nabstract contract DNSResolver is\r\n    IDNSRecordResolver,\r\n    IDNSZoneResolver,\r\n    ResolverBase\r\n{\r\n    using RRUtils for *;\r\n    using BytesUtils for bytes;\r\n\r\n    // Zone hashes for the domains.\r\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\r\n    // resource containing a single zonefile.\r\n    // node => contenthash\r\n    mapping(uint64 => mapping(bytes32 => bytes)) private versionable_zonehashes;\r\n\r\n    // The records themselves.  Stored as binary RRSETs\r\n    // node => version => name => resource => data\r\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes))))\r\n        private versionable_records;\r\n\r\n    // Count of number of entries for a given name.  Required for DNS resolvers\r\n    // when resolving wildcards.\r\n    // node => version => name => number of records\r\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => uint16)))\r\n        private versionable_nameEntriesCount;\r\n\r\n    /**\r\n     * Set one or more DNS records.  Records are supplied in wire-format.\r\n     * Records with the same node/name/resource must be supplied one after the\r\n     * other to ensure the data is updated correctly. For example, if the data\r\n     * was supplied:\r\n     *     a.example.com IN A 1.2.3.4\r\n     *     a.example.com IN A 5.6.7.8\r\n     *     www.example.com IN CNAME a.example.com.\r\n     * then this would store the two A records for a.example.com correctly as a\r\n     * single RRSET, however if the data was supplied:\r\n     *     a.example.com IN A 1.2.3.4\r\n     *     www.example.com IN CNAME a.example.com.\r\n     *     a.example.com IN A 5.6.7.8\r\n     * then this would store the first A record, the CNAME, then the second A\r\n     * record which would overwrite the first.\r\n     *\r\n     * @param node the namehash of the node for which to set the records\r\n     * @param data the DNS wire format records to set\r\n     */\r\n    function setDNSRecords(\r\n        bytes32 node,\r\n        bytes calldata data\r\n    ) external virtual authorised(node) {\r\n        uint16 resource = 0;\r\n        uint256 offset = 0;\r\n        bytes memory name;\r\n        bytes memory value;\r\n        bytes32 nameHash;\r\n        uint64 version = recordVersions[node];\r\n        // Iterate over the data to add the resource records\r\n        for (\r\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\r\n            !iter.done();\r\n            iter.next()\r\n        ) {\r\n            if (resource == 0) {\r\n                resource = iter.dnstype;\r\n                name = iter.name();\r\n                nameHash = keccak256(abi.encodePacked(name));\r\n                value = bytes(iter.rdata());\r\n            } else {\r\n                bytes memory newName = iter.name();\r\n                if (resource != iter.dnstype || !name.equals(newName)) {\r\n                    setDNSRRSet(\r\n                        node,\r\n                        name,\r\n                        resource,\r\n                        data,\r\n                        offset,\r\n                        iter.offset - offset,\r\n                        value.length == 0,\r\n                        version\r\n                    );\r\n                    resource = iter.dnstype;\r\n                    offset = iter.offset;\r\n                    name = newName;\r\n                    nameHash = keccak256(name);\r\n                    value = bytes(iter.rdata());\r\n                }\r\n            }\r\n        }\r\n        if (name.length > 0) {\r\n            setDNSRRSet(\r\n                node,\r\n                name,\r\n                resource,\r\n                data,\r\n                offset,\r\n                data.length - offset,\r\n                value.length == 0,\r\n                version\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtain a DNS record.\r\n     * @param node the namehash of the node for which to fetch the record\r\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\r\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\r\n     * @return the DNS record in wire format if present, otherwise empty\r\n     */\r\n    function dnsRecord(\r\n        bytes32 node,\r\n        bytes32 name,\r\n        uint16 resource\r\n    ) public view virtual override returns (bytes memory) {\r\n        return versionable_records[recordVersions[node]][node][name][resource];\r\n    }\r\n\r\n    /**\r\n     * Check if a given node has records.\r\n     * @param node the namehash of the node for which to check the records\r\n     * @param name the namehash of the node for which to check the records\r\n     */\r\n    function hasDNSRecords(\r\n        bytes32 node,\r\n        bytes32 name\r\n    ) public view virtual returns (bool) {\r\n        return (versionable_nameEntriesCount[recordVersions[node]][node][\r\n            name\r\n        ] != 0);\r\n    }\r\n\r\n    /**\r\n     * setZonehash sets the hash for the zone.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The zonehash to set\r\n     */\r\n    function setZonehash(\r\n        bytes32 node,\r\n        bytes calldata hash\r\n    ) external virtual authorised(node) {\r\n        uint64 currentRecordVersion = recordVersions[node];\r\n        bytes memory oldhash = versionable_zonehashes[currentRecordVersion][\r\n            node\r\n        ];\r\n        versionable_zonehashes[currentRecordVersion][node] = hash;\r\n        emit DNSZonehashChanged(node, oldhash, hash);\r\n    }\r\n\r\n    /**\r\n     * zonehash obtains the hash for the zone.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function zonehash(\r\n        bytes32 node\r\n    ) external view virtual override returns (bytes memory) {\r\n        return versionable_zonehashes[recordVersions[node]][node];\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(IDNSRecordResolver).interfaceId ||\r\n            interfaceID == type(IDNSZoneResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n\r\n    function setDNSRRSet(\r\n        bytes32 node,\r\n        bytes memory name,\r\n        uint16 resource,\r\n        bytes memory data,\r\n        uint256 offset,\r\n        uint256 size,\r\n        bool deleteRecord,\r\n        uint64 version\r\n    ) private {\r\n        bytes32 nameHash = keccak256(name);\r\n        bytes memory rrData = data.substring(offset, size);\r\n        if (deleteRecord) {\r\n            if (\r\n                versionable_records[version][node][nameHash][resource].length !=\r\n                0\r\n            ) {\r\n                versionable_nameEntriesCount[version][node][nameHash]--;\r\n            }\r\n            delete (versionable_records[version][node][nameHash][resource]);\r\n            emit DNSRecordDeleted(node, name, resource);\r\n        } else {\r\n            if (\r\n                versionable_records[version][node][nameHash][resource].length ==\r\n                0\r\n            ) {\r\n                versionable_nameEntriesCount[version][node][nameHash]++;\r\n            }\r\n            versionable_records[version][node][nameHash][resource] = rrData;\r\n            emit DNSRecordChanged(node, name, resource, rrData);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/ExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ncontract ExtendedResolver {\r\n    function resolve(\r\n        bytes memory /* name */,\r\n        bytes memory data\r\n    ) external view returns (bytes memory) {\r\n        (bool success, bytes memory result) = address(this).staticcall(data);\r\n        if (success) {\r\n            return result;\r\n        } else {\r\n            // Revert with the reason provided by the call\r\n            assembly {\r\n                revert(add(result, 0x20), mload(result))\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface IABIResolver {\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(\r\n        bytes32 node,\r\n        uint256 contentTypes\r\n    ) external view returns (uint256, bytes memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\n/**\r\n * Interface for the new (multicoin) addr function.\r\n */\r\ninterface IAddressResolver {\r\n    event AddressChanged(\r\n        bytes32 indexed node,\r\n        uint256 coinType,\r\n        bytes newAddress\r\n    );\r\n\r\n    function addr(\r\n        bytes32 node,\r\n        uint256 coinType\r\n    ) external view returns (bytes memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\n/**\r\n * Interface for the legacy (ETH-only) addr function.\r\n */\r\ninterface IAddrResolver {\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) external view returns (address payable);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface IContentHashResolver {\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(bytes32 node) external view returns (bytes memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IDNSRecordResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface IDNSRecordResolver {\r\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\r\n    event DNSRecordChanged(\r\n        bytes32 indexed node,\r\n        bytes name,\r\n        uint16 resource,\r\n        bytes record\r\n    );\r\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\r\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\r\n\r\n    /**\r\n     * Obtain a DNS record.\r\n     * @param node the namehash of the node for which to fetch the record\r\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\r\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\r\n     * @return the DNS record in wire format if present, otherwise empty\r\n     */\r\n    function dnsRecord(\r\n        bytes32 node,\r\n        bytes32 name,\r\n        uint16 resource\r\n    ) external view returns (bytes memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IDNSZoneResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface IDNSZoneResolver {\r\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\r\n    event DNSZonehashChanged(\r\n        bytes32 indexed node,\r\n        bytes lastzonehash,\r\n        bytes zonehash\r\n    );\r\n\r\n    /**\r\n     * zonehash obtains the hash for the zone.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function zonehash(bytes32 node) external view returns (bytes memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IExtendedDNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IExtendedDNSResolver {\r\n    function resolve(\r\n        bytes memory name,\r\n        bytes memory data,\r\n        bytes memory context\r\n    ) external view returns (bytes memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IExtendedResolver {\r\n    function resolve(\r\n        bytes memory name,\r\n        bytes memory data\r\n    ) external view returns (bytes memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IInterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface IInterfaceResolver {\r\n    event InterfaceChanged(\r\n        bytes32 indexed node,\r\n        bytes4 indexed interfaceID,\r\n        address implementer\r\n    );\r\n\r\n    /**\r\n     * Returns the address of a contract that implements the specified interface for this name.\r\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\r\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\r\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\r\n     * will be returned.\r\n     * @param node The ENS node to query.\r\n     * @param interfaceID The EIP 165 interface ID to check for.\r\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\r\n     */\r\n    function interfaceImplementer(\r\n        bytes32 node,\r\n        bytes4 interfaceID\r\n    ) external view returns (address);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface INameResolver {\r\n    event NameChanged(bytes32 indexed node, string name);\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) external view returns (string memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/InterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport \"../ResolverBase.sol\";\r\nimport \"./AddrResolver.sol\";\r\nimport \"./IInterfaceResolver.sol\";\r\n\r\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\r\n    mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address))) versionable_interfaces;\r\n\r\n    /**\r\n     * Sets an interface associated with a name.\r\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\r\n     * @param node The node to update.\r\n     * @param interfaceID The EIP 165 interface ID.\r\n     * @param implementer The address of a contract that implements this interface for this node.\r\n     */\r\n    function setInterface(\r\n        bytes32 node,\r\n        bytes4 interfaceID,\r\n        address implementer\r\n    ) external virtual authorised(node) {\r\n        versionable_interfaces[recordVersions[node]][node][\r\n            interfaceID\r\n        ] = implementer;\r\n        emit InterfaceChanged(node, interfaceID, implementer);\r\n    }\r\n\r\n    /**\r\n     * Returns the address of a contract that implements the specified interface for this name.\r\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\r\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\r\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\r\n     * will be returned.\r\n     * @param node The ENS node to query.\r\n     * @param interfaceID The EIP 165 interface ID to check for.\r\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\r\n     */\r\n    function interfaceImplementer(\r\n        bytes32 node,\r\n        bytes4 interfaceID\r\n    ) external view virtual override returns (address) {\r\n        address implementer = versionable_interfaces[recordVersions[node]][\r\n            node\r\n        ][interfaceID];\r\n        if (implementer != address(0)) {\r\n            return implementer;\r\n        }\r\n\r\n        address a = addr(node);\r\n        if (a == address(0)) {\r\n            return address(0);\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = a.staticcall(\r\n            abi.encodeWithSignature(\r\n                \"supportsInterface(bytes4)\",\r\n                type(IERC165).interfaceId\r\n            )\r\n        );\r\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\r\n            // EIP 165 not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        (success, returnData) = a.staticcall(\r\n            abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID)\r\n        );\r\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\r\n            // Specified interface not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(IInterfaceResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IPubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface IPubkeyResolver {\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x The X coordinate of the curve point for the public key.\r\n     * @return y The Y coordinate of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface ITextResolver {\r\n    event TextChanged(\r\n        bytes32 indexed node,\r\n        string indexed indexedKey,\r\n        string key,\r\n        string value\r\n    );\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(\r\n        bytes32 node,\r\n        string calldata key\r\n    ) external view returns (string memory);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/IVersionableResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\ninterface IVersionableResolver {\r\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\r\n\r\n    function recordVersions(bytes32 node) external view returns (uint64);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/NameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"../ResolverBase.sol\";\r\nimport \"./INameResolver.sol\";\r\n\r\nabstract contract NameResolver is INameResolver, ResolverBase {\r\n    mapping(uint64 => mapping(bytes32 => string)) versionable_names;\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     */\r\n    function setName(\r\n        bytes32 node,\r\n        string calldata newName\r\n    ) external virtual authorised(node) {\r\n        versionable_names[recordVersions[node]][node] = newName;\r\n        emit NameChanged(node, newName);\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(\r\n        bytes32 node\r\n    ) external view virtual override returns (string memory) {\r\n        return versionable_names[recordVersions[node]][node];\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(INameResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/PubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"../ResolverBase.sol\";\r\nimport \"./IPubkeyResolver.sol\";\r\n\r\nabstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    mapping(uint64 => mapping(bytes32 => PublicKey)) versionable_pubkeys;\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(\r\n        bytes32 node,\r\n        bytes32 x,\r\n        bytes32 y\r\n    ) external virtual authorised(node) {\r\n        versionable_pubkeys[recordVersions[node]][node] = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x The X coordinate of the curve point for the public key.\r\n     * @return y The Y coordinate of the curve point for the public key.\r\n     */\r\n    function pubkey(\r\n        bytes32 node\r\n    ) external view virtual override returns (bytes32 x, bytes32 y) {\r\n        uint64 currentRecordVersion = recordVersions[node];\r\n        return (\r\n            versionable_pubkeys[currentRecordVersion][node].x,\r\n            versionable_pubkeys[currentRecordVersion][node].y\r\n        );\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(IPubkeyResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/TextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"../ResolverBase.sol\";\r\nimport \"./ITextResolver.sol\";\r\n\r\nabstract contract TextResolver is ITextResolver, ResolverBase {\r\n    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(\r\n        bytes32 node,\r\n        string calldata key,\r\n        string calldata value\r\n    ) external virtual authorised(node) {\r\n        versionable_texts[recordVersions[node]][node][key] = value;\r\n        emit TextChanged(node, key, key, value);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(\r\n        bytes32 node,\r\n        string calldata key\r\n    ) external view virtual override returns (string memory) {\r\n        return versionable_texts[recordVersions[node]][node][key];\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(ITextResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/PublicResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.17 <0.9.0;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"./profiles/ABIResolver.sol\";\r\nimport \"./profiles/AddrResolver.sol\";\r\nimport \"./profiles/ContentHashResolver.sol\";\r\nimport \"./profiles/DNSResolver.sol\";\r\nimport \"./profiles/InterfaceResolver.sol\";\r\nimport \"./profiles/NameResolver.sol\";\r\nimport \"./profiles/PubkeyResolver.sol\";\r\nimport \"./profiles/TextResolver.sol\";\r\nimport \"./Multicallable.sol\";\r\nimport {ReverseClaimer} from \"../reverseRegistrar/ReverseClaimer.sol\";\r\nimport {INameWrapper} from \"../wrapper/INameWrapper.sol\";\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver is\r\n    Multicallable,\r\n    ABIResolver,\r\n    AddrResolver,\r\n    ContentHashResolver,\r\n    DNSResolver,\r\n    InterfaceResolver,\r\n    NameResolver,\r\n    PubkeyResolver,\r\n    TextResolver,\r\n    ReverseClaimer\r\n{\r\n    ENS immutable ens;\r\n    INameWrapper immutable nameWrapper;\r\n    address immutable trustedETHController;\r\n    address immutable trustedReverseRegistrar;\r\n\r\n    /**\r\n     * A mapping of operators. An address that is authorised for an address\r\n     * may make any changes to the name that the owner could, but may not update\r\n     * the set of authorisations.\r\n     * (owner, operator) => approved\r\n     */\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * A mapping of delegates. A delegate that is authorised by an owner\r\n     * for a name may make changes to the name's resolver, but may not update\r\n     * the set of token approvals.\r\n     * (owner, name, delegate) => approved\r\n     */\r\n    mapping(address => mapping(bytes32 => mapping(address => bool)))\r\n        private _tokenApprovals;\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    // Logged when a delegate is approved or  an approval is revoked.\r\n    event Approved(\r\n        address owner,\r\n        bytes32 indexed node,\r\n        address indexed delegate,\r\n        bool indexed approved\r\n    );\r\n\r\n    constructor(\r\n        ENS _ens,\r\n        INameWrapper wrapperAddress,\r\n        address _trustedETHController,\r\n        address _trustedReverseRegistrar\r\n    ) ReverseClaimer(_ens, msg.sender) {\r\n        ens = _ens;\r\n        nameWrapper = wrapperAddress;\r\n        trustedETHController = _trustedETHController;\r\n        trustedReverseRegistrar = _trustedReverseRegistrar;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        require(\r\n            msg.sender != operator,\r\n            \"ERC1155: setting approval status for self\"\r\n        );\r\n\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(\r\n        address account,\r\n        address operator\r\n    ) public view returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Approve a delegate to be able to updated records on a node.\r\n     */\r\n    function approve(bytes32 node, address delegate, bool approved) external {\r\n        require(msg.sender != delegate, \"Setting delegate status for self\");\r\n\r\n        _tokenApprovals[msg.sender][node][delegate] = approved;\r\n        emit Approved(msg.sender, node, delegate, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Check to see if the delegate has been approved by the owner for the node.\r\n     */\r\n    function isApprovedFor(\r\n        address owner,\r\n        bytes32 node,\r\n        address delegate\r\n    ) public view returns (bool) {\r\n        return _tokenApprovals[owner][node][delegate];\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view override returns (bool) {\r\n        if (\r\n            msg.sender == trustedETHController ||\r\n            msg.sender == trustedReverseRegistrar\r\n        ) {\r\n            return true;\r\n        }\r\n        address owner = ens.owner(node);\r\n        if (owner == address(nameWrapper)) {\r\n            owner = nameWrapper.ownerOf(uint256(node));\r\n        }\r\n        return\r\n            owner == msg.sender ||\r\n            isApprovedForAll(owner, msg.sender) ||\r\n            isApprovedFor(owner, node, msg.sender);\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    )\r\n        public\r\n        view\r\n        override(\r\n            Multicallable,\r\n            ABIResolver,\r\n            AddrResolver,\r\n            ContentHashResolver,\r\n            DNSResolver,\r\n            InterfaceResolver,\r\n            NameResolver,\r\n            PubkeyResolver,\r\n            TextResolver\r\n        )\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/ResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\nimport \"./profiles/IVersionableResolver.sol\";\r\n\r\nabstract contract ResolverBase is ERC165, IVersionableResolver {\r\n    mapping(bytes32 => uint64) public recordVersions;\r\n\r\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\r\n\r\n    modifier authorised(bytes32 node) {\r\n        require(isAuthorised(node));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Increments the record version associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     */\r\n    function clearRecords(bytes32 node) public virtual authorised(node) {\r\n        recordVersions[node]++;\r\n        emit VersionChanged(node, recordVersions[node]);\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceID == type(IVersionableResolver).interfaceId ||\r\n            super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/reverseRegistrar/IReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ninterface IReverseRegistrar {\r\n    function setDefaultResolver(address resolver) external;\r\n\r\n    function claim(address owner) external returns (bytes32);\r\n\r\n    function claimForAddr(\r\n        address addr,\r\n        address owner,\r\n        address resolver\r\n    ) external returns (bytes32);\r\n\r\n    function claimWithResolver(\r\n        address owner,\r\n        address resolver\r\n    ) external returns (bytes32);\r\n\r\n    function setName(string memory name) external returns (bytes32);\r\n\r\n    function setNameForAddr(\r\n        address addr,\r\n        address owner,\r\n        address resolver,\r\n        string memory name\r\n    ) external returns (bytes32);\r\n\r\n    function node(address addr) external pure returns (bytes32);\r\n}\r\n"
    },
    "contracts/reverseRegistrar/ReverseClaimer.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.17 <0.9.0;\r\n\r\nimport {ENS} from \"../registry/ENS.sol\";\r\nimport {IReverseRegistrar} from \"../reverseRegistrar/IReverseRegistrar.sol\";\r\n\r\ncontract ReverseClaimer {\r\n    bytes32 constant ADDR_REVERSE_NODE =\r\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    constructor(ENS ens, address claimant) {\r\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\r\n            ens.owner(ADDR_REVERSE_NODE)\r\n        );\r\n        reverseRegistrar.claim(claimant);\r\n    }\r\n}\r\n"
    },
    "contracts/root/Controllable.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) public controllers;\r\n\r\n    event ControllerChanged(address indexed controller, bool enabled);\r\n\r\n    modifier onlyController() {\r\n        require(\r\n            controllers[msg.sender],\r\n            \"Controllable: Caller is not a controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setController(address controller, bool enabled) public onlyOwner {\r\n        controllers[controller] = enabled;\r\n        emit ControllerChanged(controller, enabled);\r\n    }\r\n}\r\n"
    },
    "contracts/root/Ownable.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function isOwner(address addr) public view returns (bool) {\r\n        return owner == addr;\r\n    }\r\n}\r\n"
    },
    "contracts/root/Root.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./Controllable.sol\";\r\n\r\ncontract Root is Ownable, Controllable {\r\n    bytes32 private constant ROOT_NODE = bytes32(0);\r\n\r\n    bytes4 private constant INTERFACE_META_ID =\r\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n\r\n    event TLDLocked(bytes32 indexed label);\r\n\r\n    ENS public ens;\r\n    mapping(bytes32 => bool) public locked;\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n    }\r\n\r\n    function setSubnodeOwner(\r\n        bytes32 label,\r\n        address owner\r\n    ) external onlyController {\r\n        require(!locked[label]);\r\n        ens.setSubnodeOwner(ROOT_NODE, label, owner);\r\n    }\r\n\r\n    function setResolver(address resolver) external onlyOwner {\r\n        ens.setResolver(ROOT_NODE, resolver);\r\n    }\r\n\r\n    function lock(bytes32 label) external onlyOwner {\r\n        emit TLDLocked(label);\r\n        locked[label] = true;\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) external pure returns (bool) {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/HexUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nlibrary HexUtils {\r\n    /**\r\n     * @dev Attempts to parse bytes32 from a hex string\r\n     * @param str The string to parse\r\n     * @param idx The offset to start parsing at\r\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\r\n     */\r\n    function hexStringToBytes32(\r\n        bytes memory str,\r\n        uint256 idx,\r\n        uint256 lastIdx\r\n    ) internal pure returns (bytes32 r, bool valid) {\r\n        valid = true;\r\n        assembly {\r\n            // check that the index to read to is not past the end of the string\r\n            if gt(lastIdx, mload(str)) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function getHex(c) -> ascii {\r\n                // chars 48-57: 0-9\r\n                if and(gt(c, 47), lt(c, 58)) {\r\n                    ascii := sub(c, 48)\r\n                    leave\r\n                }\r\n                // chars 65-70: A-F\r\n                if and(gt(c, 64), lt(c, 71)) {\r\n                    ascii := add(sub(c, 65), 10)\r\n                    leave\r\n                }\r\n                // chars 97-102: a-f\r\n                if and(gt(c, 96), lt(c, 103)) {\r\n                    ascii := add(sub(c, 97), 10)\r\n                    leave\r\n                }\r\n                // invalid char\r\n                ascii := 0xff\r\n            }\r\n\r\n            let ptr := add(str, 32)\r\n            for {\r\n                let i := idx\r\n            } lt(i, lastIdx) {\r\n                i := add(i, 2)\r\n            } {\r\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\r\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\r\n                // if either byte is invalid, set invalid and break loop\r\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\r\n                    valid := false\r\n                    break\r\n                }\r\n                let combined := or(shl(4, byte1), byte2)\r\n                r := or(shl(8, r), combined)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to parse an address from a hex string\r\n     * @param str The string to parse\r\n     * @param idx The offset to start parsing at\r\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\r\n     */\r\n    function hexToAddress(\r\n        bytes memory str,\r\n        uint256 idx,\r\n        uint256 lastIdx\r\n    ) internal pure returns (address, bool) {\r\n        if (lastIdx - idx < 40) return (address(0x0), false);\r\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\r\n        return (address(uint160(uint256(r))), valid);\r\n    }\r\n}\r\n"
    },
    "contracts/wrapper/IMetadataService.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ~0.8.17;\r\n\r\ninterface IMetadataService {\r\n    function uri(uint256) external view returns (string memory);\r\n}\r\n"
    },
    "contracts/wrapper/INameWrapper.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ~0.8.17;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"../ethregistrar/IBaseRegistrar.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"./IMetadataService.sol\";\r\nimport \"./INameWrapperUpgrade.sol\";\r\n\r\nuint32 constant CANNOT_UNWRAP = 1;\r\nuint32 constant CANNOT_BURN_FUSES = 2;\r\nuint32 constant CANNOT_TRANSFER = 4;\r\nuint32 constant CANNOT_SET_RESOLVER = 8;\r\nuint32 constant CANNOT_SET_TTL = 16;\r\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\r\nuint32 constant CANNOT_APPROVE = 64;\r\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\r\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\r\nuint32 constant IS_DOT_ETH = 1 << 17;\r\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\r\nuint32 constant CAN_DO_EVERYTHING = 0;\r\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\r\n// all fuses apart from IS_DOT_ETH\r\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\r\n\r\ninterface INameWrapper is IERC1155 {\r\n    event NameWrapped(\r\n        bytes32 indexed node,\r\n        bytes name,\r\n        address owner,\r\n        uint32 fuses,\r\n        uint64 expiry\r\n    );\r\n\r\n    event NameUnwrapped(bytes32 indexed node, address owner);\r\n\r\n    event FusesSet(bytes32 indexed node, uint32 fuses);\r\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\r\n\r\n    function ens() external view returns (ENS);\r\n\r\n    function registrar() external view returns (IBaseRegistrar);\r\n\r\n    function metadataService() external view returns (IMetadataService);\r\n\r\n    function names(bytes32) external view returns (bytes memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function upgradeContract() external view returns (INameWrapperUpgrade);\r\n\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n\r\n    function wrap(\r\n        bytes calldata name,\r\n        address wrappedOwner,\r\n        address resolver\r\n    ) external;\r\n\r\n    function wrapETH2LD(\r\n        string calldata label,\r\n        address wrappedOwner,\r\n        uint16 ownerControlledFuses,\r\n        address resolver\r\n    ) external returns (uint64 expires);\r\n\r\n    function registerAndWrapETH2LD(\r\n        string calldata label,\r\n        address wrappedOwner,\r\n        uint256 duration,\r\n        address resolver,\r\n        uint16 ownerControlledFuses\r\n    ) external returns (uint256 registrarExpiry);\r\n\r\n    function renew(\r\n        uint256 labelHash,\r\n        uint256 duration\r\n    ) external returns (uint256 expires);\r\n\r\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\r\n\r\n    function unwrapETH2LD(\r\n        bytes32 label,\r\n        address newRegistrant,\r\n        address newController\r\n    ) external;\r\n\r\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\r\n\r\n    function setFuses(\r\n        bytes32 node,\r\n        uint16 ownerControlledFuses\r\n    ) external returns (uint32 newFuses);\r\n\r\n    function setChildFuses(\r\n        bytes32 parentNode,\r\n        bytes32 labelhash,\r\n        uint32 fuses,\r\n        uint64 expiry\r\n    ) external;\r\n\r\n    function setSubnodeRecord(\r\n        bytes32 node,\r\n        string calldata label,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl,\r\n        uint32 fuses,\r\n        uint64 expiry\r\n    ) external returns (bytes32);\r\n\r\n    function setRecord(\r\n        bytes32 node,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeOwner(\r\n        bytes32 node,\r\n        string calldata label,\r\n        address newOwner,\r\n        uint32 fuses,\r\n        uint64 expiry\r\n    ) external returns (bytes32);\r\n\r\n    function extendExpiry(\r\n        bytes32 node,\r\n        bytes32 labelhash,\r\n        uint64 expiry\r\n    ) external returns (uint64);\r\n\r\n    function canModifyName(\r\n        bytes32 node,\r\n        address addr\r\n    ) external view returns (bool);\r\n\r\n    function setResolver(bytes32 node, address resolver) external;\r\n\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n\r\n    function ownerOf(uint256 id) external view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n\r\n    function getData(\r\n        uint256 id\r\n    ) external view returns (address, uint32, uint64);\r\n\r\n    function setMetadataService(IMetadataService _metadataService) external;\r\n\r\n    function uri(uint256 tokenId) external view returns (string memory);\r\n\r\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\r\n\r\n    function allFusesBurned(\r\n        bytes32 node,\r\n        uint32 fuseMask\r\n    ) external view returns (bool);\r\n\r\n    function isWrapped(bytes32) external view returns (bool);\r\n\r\n    function isWrapped(bytes32, bytes32) external view returns (bool);\r\n}\r\n"
    },
    "contracts/wrapper/INameWrapperUpgrade.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ~0.8.17;\r\n\r\ninterface INameWrapperUpgrade {\r\n    function wrapFromUpgrade(\r\n        bytes calldata name,\r\n        address wrappedOwner,\r\n        uint32 fuses,\r\n        uint64 expiry,\r\n        address approved,\r\n        bytes calldata extraData\r\n    ) external;\r\n}\r\n"
    },
    "test/dnssec-oracle/TestBytesUtils.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../../contracts/dnssec-oracle/RRUtils.sol\";\r\nimport \"../../contracts/dnssec-oracle/BytesUtils.sol\";\r\n\r\ncontract TestBytesUtils {\r\n    using BytesUtils for *;\r\n\r\n    function testKeccak() public pure {\r\n        require(\r\n            \"\".keccak(0, 0) ==\r\n                bytes32(\r\n                    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\r\n                ),\r\n            \"Incorrect hash of empty string\"\r\n        );\r\n        require(\r\n            \"foo\".keccak(0, 3) ==\r\n                bytes32(\r\n                    0x41b1a0649752af1b28b3dc29a1556eee781e4a4c3a1f7f53f90fa834de098c4d\r\n                ),\r\n            \"Incorrect hash of 'foo'\"\r\n        );\r\n        require(\r\n            \"foo\".keccak(0, 0) ==\r\n                bytes32(\r\n                    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\r\n                ),\r\n            \"Incorrect hash of empty string\"\r\n        );\r\n    }\r\n\r\n    function testEquals() public pure {\r\n        require(\"hello\".equals(\"hello\") == true, \"String equality\");\r\n        require(\"hello\".equals(\"goodbye\") == false, \"String inequality\");\r\n        require(\r\n            \"hello\".equals(1, \"ello\") == true,\r\n            \"Substring to string equality\"\r\n        );\r\n        require(\r\n            \"hello\".equals(1, \"jello\", 1, 4) == true,\r\n            \"Substring to substring equality\"\r\n        );\r\n        require(\r\n            \"zhello\".equals(1, \"abchello\", 3) == true,\r\n            \"Compare different value with multiple length\"\r\n        );\r\n        require(\r\n            \"0x0102030000\".equals(0, \"0x010203\") == false,\r\n            \"Compare with offset and trailing bytes\"\r\n        );\r\n    }\r\n\r\n    function testComparePartial() public pure {\r\n        require(\r\n            \"xax\".compare(1, 1, \"xxbxx\", 2, 1) < 0 == true,\r\n            \"Compare same length\"\r\n        );\r\n        require(\r\n            \"xax\".compare(1, 1, \"xxabxx\", 2, 2) < 0 == true,\r\n            \"Compare different length\"\r\n        );\r\n        require(\r\n            \"xax\".compare(1, 1, \"xxaxx\", 2, 1) == 0 == true,\r\n            \"Compare same with different offset\"\r\n        );\r\n        require(\r\n            \"01234567890123450123456789012345ab\".compare(\r\n                0,\r\n                33,\r\n                \"01234567890123450123456789012345aa\",\r\n                0,\r\n                33\r\n            ) ==\r\n                0 ==\r\n                true,\r\n            \"Compare different long strings same length smaller partial length which must be equal\"\r\n        );\r\n        require(\r\n            \"01234567890123450123456789012345ab\".compare(\r\n                0,\r\n                33,\r\n                \"01234567890123450123456789012345aa\",\r\n                0,\r\n                34\r\n            ) <\r\n                0 ==\r\n                true,\r\n            \"Compare long strings same length different partial length\"\r\n        );\r\n        require(\r\n            \"0123456789012345012345678901234a\".compare(\r\n                0,\r\n                32,\r\n                \"0123456789012345012345678901234b\",\r\n                0,\r\n                32\r\n            ) <\r\n                0 ==\r\n                true,\r\n            \"Compare strings exactly 32 characters long\"\r\n        );\r\n    }\r\n\r\n    function testCompare() public pure {\r\n        require(\"a\".compare(\"a\") == 0 == true, \"Compare equal\");\r\n        require(\r\n            \"a\".compare(\"b\") < 0 == true,\r\n            \"Compare different value with same length\"\r\n        );\r\n        require(\r\n            \"b\".compare(\"a\") > 0 == true,\r\n            \"Compare different value with same length\"\r\n        );\r\n        require(\r\n            \"aa\".compare(\"ab\") < 0 == true,\r\n            \"Compare different value with multiple length\"\r\n        );\r\n        require(\r\n            \"a\".compare(\"aa\") < 0 == true,\r\n            \"Compare different value with different length\"\r\n        );\r\n        require(\r\n            \"aa\".compare(\"a\") > 0 == true,\r\n            \"Compare different value with different length\"\r\n        );\r\n        bytes memory longChar = \"1234567890123456789012345678901234\";\r\n        require(\r\n            longChar.compare(longChar) == 0 == true,\r\n            \"Compares more than 32 bytes char\"\r\n        );\r\n        bytes memory otherLongChar = \"2234567890123456789012345678901234\";\r\n        require(\r\n            longChar.compare(otherLongChar) < 0 == true,\r\n            \"Compare long char with difference at start\"\r\n        );\r\n    }\r\n\r\n    function testSubstring() public pure {\r\n        require(\r\n            keccak256(bytes(\"hello\".substring(0, 0))) == keccak256(bytes(\"\")),\r\n            \"Copy 0 bytes\"\r\n        );\r\n        require(\r\n            keccak256(bytes(\"hello\".substring(0, 4))) ==\r\n                keccak256(bytes(\"hell\")),\r\n            \"Copy substring\"\r\n        );\r\n        require(\r\n            keccak256(bytes(\"hello\".substring(1, 4))) ==\r\n                keccak256(bytes(\"ello\")),\r\n            \"Copy substring\"\r\n        );\r\n        require(\r\n            keccak256(bytes(\"hello\".substring(0, 5))) ==\r\n                keccak256(bytes(\"hello\")),\r\n            \"Copy whole string\"\r\n        );\r\n    }\r\n\r\n    function testReadUint8() public pure {\r\n        require(uint(\"a\".readUint8(0)) == 0x61, \"a == 0x61\");\r\n        require(uint(\"ba\".readUint8(1)) == 0x61, \"a == 0x61\");\r\n    }\r\n\r\n    function testReadUint16() public pure {\r\n        require(uint(\"abc\".readUint16(1)) == 0x6263, \"Read uint 16\");\r\n    }\r\n\r\n    function testReadUint32() public pure {\r\n        require(uint(\"abcde\".readUint32(1)) == 0x62636465, \"Read uint 32\");\r\n    }\r\n\r\n    function testReadBytes20() public pure {\r\n        require(\r\n            bytes32(\"abcdefghijklmnopqrstuv\".readBytes20(1)) ==\r\n                bytes32(\r\n                    0x62636465666768696a6b6c6d6e6f707172737475000000000000000000000000\r\n                ),\r\n            \"readBytes20\"\r\n        );\r\n    }\r\n\r\n    function testReadBytes32() public pure {\r\n        require(\r\n            \"0123456789abcdef0123456789abcdef\".readBytes32(0) ==\r\n                bytes32(\r\n                    0x3031323334353637383961626364656630313233343536373839616263646566\r\n                ),\r\n            \"readBytes32\"\r\n        );\r\n    }\r\n\r\n    function testBase32HexDecodeWord() public pure {\r\n        require(\r\n            \"C4\".base32HexDecodeWord(0, 2) == bytes32(bytes1(\"a\")),\r\n            \"Decode 'a'\"\r\n        );\r\n        require(\r\n            \"C5GG\".base32HexDecodeWord(0, 4) == bytes32(bytes2(\"aa\")),\r\n            \"Decode 'aa'\"\r\n        );\r\n        require(\r\n            \"C5GM2\".base32HexDecodeWord(0, 5) == bytes32(bytes3(\"aaa\")),\r\n            \"Decode 'aaa'\"\r\n        );\r\n        require(\r\n            \"C5GM2O8\".base32HexDecodeWord(0, 7) == bytes32(bytes4(\"aaaa\")),\r\n            \"Decode 'aaaa'\"\r\n        );\r\n        require(\r\n            \"C5GM2OB1\".base32HexDecodeWord(0, 8) == bytes32(bytes5(\"aaaaa\")),\r\n            \"Decode 'aaaaa'\"\r\n        );\r\n        require(\r\n            \"c5gm2Ob1\".base32HexDecodeWord(0, 8) == bytes32(bytes5(\"aaaaa\")),\r\n            \"Decode 'aaaaa' lowercase\"\r\n        );\r\n        require(\r\n            \"C5H66P35CPJMGQBADDM6QRJFE1ON4SRKELR7EU3PF8\".base32HexDecodeWord(\r\n                0,\r\n                42\r\n            ) == bytes32(bytes26(\"abcdefghijklmnopqrstuvwxyz\")),\r\n            \"Decode alphabet\"\r\n        );\r\n        require(\r\n            \"c5h66p35cpjmgqbaddm6qrjfe1on4srkelr7eu3pf8\".base32HexDecodeWord(\r\n                0,\r\n                42\r\n            ) == bytes32(bytes26(\"abcdefghijklmnopqrstuvwxyz\")),\r\n            \"Decode alphabet lowercase\"\r\n        );\r\n        require(\r\n            \"C5GM2OB1C5GM2OB1C5GM2OB1C5GM2OB1C5GM2OB1C5GM2OB1C5GG\"\r\n                .base32HexDecodeWord(0, 52) ==\r\n                bytes32(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"),\r\n            \"Decode 32*'a'\"\r\n        );\r\n        require(\r\n            \" bst4hlje7r0o8c8p4o8q582lm0ejmiqt\\x07matoken\\x03xyz\\x00\"\r\n                .base32HexDecodeWord(1, 32) ==\r\n                bytes32(hex\"5f3a48d66e3ec18431192611a2a055b01d3b4b5d\"),\r\n            \"Decode real bytes32hex\"\r\n        );\r\n    }\r\n}\r\n"
    },
    "test/dnssec-oracle/TestRRUtils.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../../contracts/dnssec-oracle/RRUtils.sol\";\r\nimport \"../../contracts/dnssec-oracle/BytesUtils.sol\";\r\n\r\ncontract TestRRUtils {\r\n    using BytesUtils for *;\r\n    using RRUtils for *;\r\n\r\n    uint16 constant DNSTYPE_A = 1;\r\n    uint16 constant DNSTYPE_CNAME = 5;\r\n    uint16 constant DNSTYPE_MX = 15;\r\n    uint16 constant DNSTYPE_TEXT = 16;\r\n    uint16 constant DNSTYPE_RRSIG = 46;\r\n    uint16 constant DNSTYPE_TYPE1234 = 1234;\r\n\r\n    function testNameLength() public pure {\r\n        require(hex\"00\".nameLength(0) == 1, \"nameLength('.') == 1\");\r\n        require(hex\"0361626300\".nameLength(4) == 1, \"nameLength('.') == 1\");\r\n        require(hex\"0361626300\".nameLength(0) == 5, \"nameLength('abc.') == 5\");\r\n    }\r\n\r\n    function testLabelCount() public pure {\r\n        require(hex\"00\".labelCount(0) == 0, \"labelCount('.') == 0\");\r\n        require(hex\"016100\".labelCount(0) == 1, \"labelCount('a.') == 1\");\r\n        require(\r\n            hex\"016201610000\".labelCount(0) == 2,\r\n            \"labelCount('b.a.') == 2\"\r\n        );\r\n        require(\r\n            hex\"066574686c61620378797a00\".labelCount(6 + 1) == 1,\r\n            \"nameLength('(bthlab).xyz.') == 6\"\r\n        );\r\n    }\r\n\r\n    function testIterateRRs() public pure {\r\n        // a. IN A 3600 127.0.0.1\r\n        // b.a. IN A 3600 192.168.1.1\r\n        bytes\r\n            memory rrs = hex\"0161000001000100000e1000047400000101620161000001000100000e100004c0a80101\";\r\n        bytes[2] memory names = [bytes(hex\"016100\"), bytes(hex\"0162016100\")];\r\n        bytes[2] memory rdatas = [bytes(hex\"74000001\"), bytes(hex\"c0a80101\")];\r\n        uint i = 0;\r\n        for (\r\n            RRUtils.RRIterator memory iter = rrs.iterateRRs(0);\r\n            !iter.done();\r\n            iter.next()\r\n        ) {\r\n            require(uint(iter.dnstype) == 1, \"Type matches\");\r\n            require(uint(iter.class) == 1, \"Class matches\");\r\n            require(uint(iter.ttl) == 3600, \"TTL matches\");\r\n            require(\r\n                keccak256(iter.name()) == keccak256(names[i]),\r\n                \"Name matches\"\r\n            );\r\n            require(\r\n                keccak256(iter.rdata()) == keccak256(rdatas[i]),\r\n                \"Rdata matches\"\r\n            );\r\n            i++;\r\n        }\r\n        require(i == 2, \"Expected 2 records\");\r\n    }\r\n\r\n    // Canonical ordering https://tools.ietf.org/html/rfc4034#section-6.1\r\n    function testCompareNames() public pure {\r\n        bytes memory bthLabXyz = hex\"066274686c61620378797a00\";\r\n        bytes memory ethLabXyz = hex\"066574686c61620378797a00\";\r\n        bytes memory xyz = hex\"0378797a00\";\r\n        bytes memory a_b_c = hex\"01610162016300\";\r\n        bytes memory b_b_c = hex\"01620162016300\";\r\n        bytes memory c = hex\"016300\";\r\n        bytes memory d = hex\"016400\";\r\n        bytes memory a_d_c = hex\"01610164016300\";\r\n        bytes memory b_a_c = hex\"01620161016300\";\r\n        bytes memory ab_c_d = hex\"0261620163016400\";\r\n        bytes memory a_c_d = hex\"01610163016400\";\r\n        bytes\r\n            memory verylong1_eth = hex\"223031323334353637383930313233343536373839303132333435363738393031613031303132333435363738393031323334353637383930313233343536373839303132333435363738393031323334353637380365746800\";\r\n        bytes\r\n            memory verylong2_eth = hex\"2130313233343536373839303132333435363738393031323334353637383930316131303132333435363738393031323334353637383930313233343536373839303132333435363738393031323334353637380365746800\";\r\n\r\n        require(\r\n            hex\"0301616100\".compareNames(hex\"0302616200\") < 0,\r\n            \"label lengths are correctly checked\"\r\n        );\r\n        require(\r\n            a_b_c.compareNames(c) > 0,\r\n            \"one name has a difference of >1 label to with the same root name\"\r\n        );\r\n        require(\r\n            a_b_c.compareNames(d) < 0,\r\n            \"one name has a difference of >1 label to with different root name\"\r\n        );\r\n        require(\r\n            a_b_c.compareNames(a_d_c) < 0,\r\n            \"two names start the same but have differences in later labels\"\r\n        );\r\n        require(\r\n            a_b_c.compareNames(b_a_c) > 0,\r\n            \"the first label sorts later, but the first label sorts earlier\"\r\n        );\r\n        require(\r\n            ab_c_d.compareNames(a_c_d) > 0,\r\n            \"two names where the first label on one is a prefix of the first label on the other\"\r\n        );\r\n        require(\r\n            a_b_c.compareNames(b_b_c) < 0,\r\n            \"two names where the first label on one is a prefix of the first label on the other\"\r\n        );\r\n        require(xyz.compareNames(ethLabXyz) < 0, \"xyz comes before ethLab.xyz\");\r\n        require(\r\n            bthLabXyz.compareNames(ethLabXyz) < 0,\r\n            \"bthLab.xyz comes before ethLab.xyz\"\r\n        );\r\n        require(\r\n            bthLabXyz.compareNames(bthLabXyz) == 0,\r\n            \"bthLab.xyz and bthLab.xyz are the same\"\r\n        );\r\n        require(\r\n            ethLabXyz.compareNames(bthLabXyz) > 0,\r\n            \"ethLab.xyz comes after bethLab.xyz\"\r\n        );\r\n        require(bthLabXyz.compareNames(xyz) > 0, \"bthLab.xyz comes after xyz\");\r\n\r\n        require(\r\n            verylong1_eth.compareNames(verylong2_eth) > 0,\r\n            \"longa.vlong.trx comes after long.vlong.trx\"\r\n        );\r\n    }\r\n\r\n    function testSerialNumberGt() public pure {\r\n        require(RRUtils.serialNumberGte(1, 0), \"1 >= 0\");\r\n        require(!RRUtils.serialNumberGte(0, 1), \"!(0 <= 1)\");\r\n        require(RRUtils.serialNumberGte(0, 0xFFFFFFFF), \"0 >= 0xFFFFFFFF\");\r\n        require(!RRUtils.serialNumberGte(0xFFFFFFFF, 0), \"!(0 <= 0xFFFFFFFF)\");\r\n        require(\r\n            RRUtils.serialNumberGte(0x11111111, 0xAAAAAAAA),\r\n            \"0x11111111 >= 0xAAAAAAAA\"\r\n        );\r\n        require(RRUtils.serialNumberGte(1, 1), \"1 >= 1\");\r\n    }\r\n\r\n    function testKeyTag() public view {\r\n        require(\r\n            hex\"0101030803010001a80020a95566ba42e886bb804cda84e47ef56dbd7aec612615552cec906d2116d0ef207028c51554144dfeafe7c7cb8f005dd18234133ac0710a81182ce1fd14ad2283bc83435f9df2f6313251931a176df0da51e54f42e604860dfb359580250f559cc543c4ffd51cbe3de8cfd06719237f9fc47ee729da06835fa452e825e9a18ebc2ecbcf563474652c33cf56a9033bcdf5d973121797ec8089041b6e03a1b72d0a735b984e03687309332324f27c2dba85e9db15e83a0143382e974b0621c18e625ecec907577d9e7bade95241a81ebbe8a901d4d3276e40b114c0a2e6fc38d19c2e6aab02644b2813f575fc21601e0dee49cd9ee96a43103e524d62873d\"\r\n                .computeKeytag() == 19036,\r\n            \"Invalid keytag\"\r\n        );\r\n        require(\r\n            hex\"010003050440000003ba2fa05a75e173bede89eb71831ab14035f2408ad09df4d8dc8f8f72e8f13506feaddf7b04cb14958b82966e3420562302c4002bc4fd088432e160519bb14dae82443850c1423e06085710b5caf070d46b7ba7e481414f6a5fe225fdca984c959091645d0cf1c9a1a313d7e7fb7ba60b967b71a65f8cef2c3768e11b081c8fcf\"\r\n                .computeKeytag() == 21693,\r\n            \"Invalid keytag (2)\"\r\n        );\r\n        require(\r\n            hex\"0100030503010001bfa54c38d909fabb0f937d70d775ba0df4c0badb09707d995249406950407a621c794c68b186b15dbf8f9f9ea231e9f96414ccda4eceb50b17a9ac6c4bd4b95da04849e96ee791578b703bc9ae184fb1794bac792a0787f693a40f19f523ee6dbd3599dbaaa9a50437926ecf6438845d1d49448962524f2a1a7a36b3a0a1eca3\"\r\n                .computeKeytag() == 33630\r\n        );\r\n        require(\r\n            hex\"0101030803010001acffb409bcc939f831f7a1e5ec88f7a59255ec53040be432027390a4ce896d6f9086f3c5e177fbfe118163aaec7af1462c47945944c4e2c026be5e98bbcded25978272e1e3e079c5094d573f0e83c92f02b32d3513b1550b826929c80dd0f92cac966d17769fd5867b647c3f38029abdc48152eb8f207159ecc5d232c7c1537c79f4b7ac28ff11682f21681bf6d6aba555032bf6f9f036beb2aaa5b3778d6eebfba6bf9ea191be4ab0caea759e2f773a1f9029c73ecb8d5735b9321db085f1b8e2d8038fe2941992548cee0d67dd4547e11dd63af9c9fc1c5466fb684cf009d7197c2cf79e792ab501e6a8a1ca519af2cb9b5f6367e94c0d47502451357be1b5\"\r\n                .computeKeytag() == 20326,\r\n            \"Invalid keytag (3)\"\r\n        );\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}