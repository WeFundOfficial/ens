{
  "address": "0xBbC6854E53d6Bd3D9317Aef372c70A5C4899a7E2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_anchors",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "class",
          "type": "uint16"
        }
      ],
      "name": "InvalidClass",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "labelsExpected",
          "type": "uint256"
        }
      ],
      "name": "InvalidLabelCount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "proofType",
          "type": "uint16"
        }
      ],
      "name": "InvalidProofType",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidRRSet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "rrsetName",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signerName",
          "type": "bytes"
        }
      ],
      "name": "InvalidSignerName",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "signerName",
          "type": "bytes"
        }
      ],
      "name": "NoMatchingProof",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "signerName",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "proofName",
          "type": "bytes"
        }
      ],
      "name": "ProofNameMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "expiration",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "now",
          "type": "uint32"
        }
      ],
      "name": "SignatureExpired",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "inception",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "now",
          "type": "uint32"
        }
      ],
      "name": "SignatureNotValidYet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "rrsetType",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "sigType",
          "type": "uint16"
        }
      ],
      "name": "SignatureTypeMismatch",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "id",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "AlgorithmUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "id",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "DigestUpdated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "algorithms",
      "outputs": [
        {
          "internalType": "contract Algorithm",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "anchors",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "digests",
      "outputs": [
        {
          "internalType": "contract Digest",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "id",
          "type": "uint8"
        },
        {
          "internalType": "contract Algorithm",
          "name": "algo",
          "type": "address"
        }
      ],
      "name": "setAlgorithm",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "id",
          "type": "uint8"
        },
        {
          "internalType": "contract Digest",
          "name": "digest",
          "type": "address"
        }
      ],
      "name": "setDigest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "setOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "rrset",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "sig",
              "type": "bytes"
            }
          ],
          "internalType": "struct DNSSEC.RRSetWithSignature[]",
          "name": "input",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "now",
          "type": "uint256"
        }
      ],
      "name": "verifyRRSet",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "rrs",
          "type": "bytes"
        },
        {
          "internalType": "uint32",
          "name": "inception",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "rrset",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "sig",
              "type": "bytes"
            }
          ],
          "internalType": "struct DNSSEC.RRSetWithSignature[]",
          "name": "input",
          "type": "tuple[]"
        }
      ],
      "name": "verifyRRSet",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "rrs",
          "type": "bytes"
        },
        {
          "internalType": "uint32",
          "name": "inception",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x3835480a9c14c979dbf2f5f5cf6a7625f9aaf883567708639abd42390cdb934b",
  "receipt": {
    "to": null,
    "from": "0x81fc7b86316Bb26b4ceC8f38121Bab70b39672F2",
    "contractAddress": "0xBbC6854E53d6Bd3D9317Aef372c70A5C4899a7E2",
    "transactionIndex": 73,
    "gasUsed": "1832871",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa53398ae63a587de85e7dfb07d7dfa432b4b2e1a8bfb8c146d3fa42b3a415edc",
    "transactionHash": "0x3835480a9c14c979dbf2f5f5cf6a7625f9aaf883567708639abd42390cdb934b",
    "logs": [],
    "blockNumber": 9562219,
    "cumulativeGasUsed": "12090169",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x00002b000100000e1000244a5c080249aac11d7b6f6446702e54a1607371607a1a41855200fd2ce1cdde32f24e8fb500002b000100000e1000244f660802e06d44b80b8f1d39a95c0b0d7c65d08458e880409bbc683457104237c7f8ec8d00002b000100000e10000404fefdfd"
  ],
  "numDeployments": 2,
  "solcInputHash": "0abd204bc166027a79b4a4534bc42e69",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_anchors\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"class\",\"type\":\"uint16\"}],\"name\":\"InvalidClass\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"labelsExpected\",\"type\":\"uint256\"}],\"name\":\"InvalidLabelCount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proofType\",\"type\":\"uint16\"}],\"name\":\"InvalidProofType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRRSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rrsetName\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signerName\",\"type\":\"bytes\"}],\"name\":\"InvalidSignerName\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signerName\",\"type\":\"bytes\"}],\"name\":\"NoMatchingProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signerName\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofName\",\"type\":\"bytes\"}],\"name\":\"ProofNameMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"expiration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"now\",\"type\":\"uint32\"}],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"inception\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"now\",\"type\":\"uint32\"}],\"name\":\"SignatureNotValidYet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"rrsetType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sigType\",\"type\":\"uint16\"}],\"name\":\"SignatureTypeMismatch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AlgorithmUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"DigestUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"algorithms\",\"outputs\":[{\"internalType\":\"contract Algorithm\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anchors\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"digests\",\"outputs\":[{\"internalType\":\"contract Digest\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"contract Algorithm\",\"name\":\"algo\",\"type\":\"address\"}],\"name\":\"setAlgorithm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"contract Digest\",\"name\":\"digest\",\"type\":\"address\"}],\"name\":\"setDigest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rrset\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct DNSSEC.RRSetWithSignature[]\",\"name\":\"input\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"now\",\"type\":\"uint256\"}],\"name\":\"verifyRRSet\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"rrs\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"inception\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rrset\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct DNSSEC.RRSetWithSignature[]\",\"name\":\"input\",\"type\":\"tuple[]\"}],\"name\":\"verifyRRSet\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"rrs\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"inception\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Constructor.\",\"params\":{\"_anchors\":\"The binary format RR entries for the root DS records.\"}},\"setAlgorithm(uint8,address)\":{\"details\":\"Sets the contract address for a signature verification algorithm.      Callable only by the owner.\",\"params\":{\"algo\":\"The address of the algorithm contract.\",\"id\":\"The algorithm ID\"}},\"setDigest(uint8,address)\":{\"details\":\"Sets the contract address for a digest verification algorithm.      Callable only by the owner.\",\"params\":{\"digest\":\"The address of the digest contract.\",\"id\":\"The digest ID\"}},\"verifyRRSet((bytes,bytes)[])\":{\"details\":\"Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\",\"params\":{\"input\":\"A list of signed RRSets.\"},\"returns\":{\"inception\":\"The inception time of the signed record set.\",\"rrs\":\"The RRData from the last RRSet in the chain.\"}},\"verifyRRSet((bytes,bytes)[],uint256)\":{\"details\":\"Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\",\"params\":{\"input\":\"A list of signed RRSets.\",\"now\":\"The Unix timestamp to validate the records at.\"},\"returns\":{\"inception\":\"The inception time of the signed record set.\",\"rrs\":\"The RRData from the last RRSet in the chain.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dnssec-oracle/DNSSECImpl.sol\":\"DNSSECImpl\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1200},\"remappings\":[]},\"sources\":{\"@ensdomains/buffer/contracts/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + newCapacity\\n            let dest := add(bufptr, newCapacity)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(newCapacity, mload(bufptr)) {\\n                mstore(bufptr, newCapacity)\\n            }\\n        }\\n        return buf;\\n    }\\n}\\n\",\"keccak256\":\"0xd6dd3b0b327288f8e1b711a609f4040fea602e2ad4bba9febdf2f33b4e56eb0c\",\"license\":\"BSD-2-Clause\"},\"contracts/dnssec-oracle/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nlibrary BytesUtils {\\r\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the keccak-256 hash of a byte range.\\r\\n     * @param self The byte string to hash.\\r\\n     * @param offset The position to start hashing at.\\r\\n     * @param len The number of bytes to hash.\\r\\n     * @return The hash of the byte range.\\r\\n     */\\r\\n    function keccak(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(offset + len <= self.length);\\r\\n        assembly {\\r\\n            ret := keccak256(add(add(self, 32), offset), len)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (int256) {\\r\\n        return compare(self, 0, self.length, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal. Comparison is done per-rune,\\r\\n     *      on unicode codepoints.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param offset The offset of self.\\r\\n     * @param len    The length of self.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @param otheroffset The offset of the other string.\\r\\n     * @param otherlen    The length of the other string.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len,\\r\\n        bytes memory other,\\r\\n        uint256 otheroffset,\\r\\n        uint256 otherlen\\r\\n    ) internal pure returns (int256) {\\r\\n        if (offset + len > self.length) {\\r\\n            revert OffsetOutOfBoundsError(offset + len, self.length);\\r\\n        }\\r\\n        if (otheroffset + otherlen > other.length) {\\r\\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\\r\\n        }\\r\\n\\r\\n        uint256 shortest = len;\\r\\n        if (otherlen < len) shortest = otherlen;\\r\\n\\r\\n        uint256 selfptr;\\r\\n        uint256 otherptr;\\r\\n\\r\\n        assembly {\\r\\n            selfptr := add(self, add(offset, 32))\\r\\n            otherptr := add(other, add(otheroffset, 32))\\r\\n        }\\r\\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\\r\\n            uint256 a;\\r\\n            uint256 b;\\r\\n            assembly {\\r\\n                a := mload(selfptr)\\r\\n                b := mload(otherptr)\\r\\n            }\\r\\n            if (a != b) {\\r\\n                // Mask out irrelevant bytes and check again\\r\\n                uint256 mask;\\r\\n                if (shortest - idx >= 32) {\\r\\n                    mask = type(uint256).max;\\r\\n                } else {\\r\\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\\r\\n                }\\r\\n                int256 diff = int256(a & mask) - int256(b & mask);\\r\\n                if (diff != 0) return diff;\\r\\n            }\\r\\n            selfptr += 32;\\r\\n            otherptr += 32;\\r\\n        }\\r\\n\\r\\n        return int256(len) - int256(otherlen);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @param len The number of bytes to compare\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bool) {\\r\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal with offsets.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            keccak(self, offset, self.length - offset) ==\\r\\n            keccak(other, otherOffset, other.length - otherOffset);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\\r\\n     *      they are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == offset + other.length &&\\r\\n            equals(self, offset, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == other.length &&\\r\\n            equals(self, 0, other, 0, self.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 8-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 8 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint8(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint8 ret) {\\r\\n        return uint8(self[idx]);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 16-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 16 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint16(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint16 ret) {\\r\\n        require(idx + 2 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint32(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint32 ret) {\\r\\n        require(idx + 4 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes32(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(idx + 32 <= self.length);\\r\\n        assembly {\\r\\n            ret := mload(add(add(self, 32), idx))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes20(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes20 ret) {\\r\\n        require(idx + 20 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(\\r\\n                mload(add(add(self, 32), idx)),\\r\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the n byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes.\\r\\n     * @param len The number of bytes.\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytesN(\\r\\n        bytes memory self,\\r\\n        uint256 idx,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(len <= 32);\\r\\n        require(idx + len <= self.length);\\r\\n        assembly {\\r\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\r\\n            ret := and(mload(add(add(self, 32), idx)), mask)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\\r\\n        // Copy word-length chunks while possible\\r\\n        for (; len >= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        unchecked {\\r\\n            uint256 mask = (256 ** (32 - len)) - 1;\\r\\n            assembly {\\r\\n                let srcpart := and(mload(src), not(mask))\\r\\n                let destpart := and(mload(dest), mask)\\r\\n                mstore(dest, or(destpart, srcpart))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Copies a substring into a new byte string.\\r\\n     * @param self The byte string to copy from.\\r\\n     * @param offset The offset to start copying at.\\r\\n     * @param len The number of bytes to copy.\\r\\n     */\\r\\n    function substring(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        require(offset + len <= self.length);\\r\\n\\r\\n        bytes memory ret = new bytes(len);\\r\\n        uint256 dest;\\r\\n        uint256 src;\\r\\n\\r\\n        assembly {\\r\\n            dest := add(ret, 32)\\r\\n            src := add(add(self, 32), offset)\\r\\n        }\\r\\n        memcpy(dest, src, len);\\r\\n\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\r\\n    // 0xFF represents invalid characters in that range.\\r\\n    bytes constant base32HexTable =\\r\\n        hex\\\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\r\\n     * @param self The data to decode.\\r\\n     * @param off Offset into the string to start at.\\r\\n     * @param len Number of characters to decode.\\r\\n     * @return The decoded data, left aligned.\\r\\n     */\\r\\n    function base32HexDecodeWord(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32) {\\r\\n        require(len <= 52);\\r\\n\\r\\n        uint256 ret = 0;\\r\\n        uint8 decoded;\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            bytes1 char = self[off + i];\\r\\n            require(char >= 0x30 && char <= 0x7A);\\r\\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\\r\\n            require(decoded <= 0x20);\\r\\n            if (i == len - 1) {\\r\\n                break;\\r\\n            }\\r\\n            ret = (ret << 5) | decoded;\\r\\n        }\\r\\n\\r\\n        uint256 bitlen = len * 5;\\r\\n        if (len % 8 == 0) {\\r\\n            // Multiple of 8 characters, no padding\\r\\n            ret = (ret << 5) | decoded;\\r\\n        } else if (len % 8 == 2) {\\r\\n            // Two extra characters - 1 byte\\r\\n            ret = (ret << 3) | (decoded >> 2);\\r\\n            bitlen -= 2;\\r\\n        } else if (len % 8 == 4) {\\r\\n            // Four extra characters - 2 bytes\\r\\n            ret = (ret << 1) | (decoded >> 4);\\r\\n            bitlen -= 4;\\r\\n        } else if (len % 8 == 5) {\\r\\n            // Five extra characters - 3 bytes\\r\\n            ret = (ret << 4) | (decoded >> 1);\\r\\n            bitlen -= 1;\\r\\n        } else if (len % 8 == 7) {\\r\\n            // Seven extra characters - 4 bytes\\r\\n            ret = (ret << 2) | (decoded >> 3);\\r\\n            bitlen -= 3;\\r\\n        } else {\\r\\n            revert();\\r\\n        }\\r\\n\\r\\n        return bytes32(ret << (256 - bitlen));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\\r\\n     * @param self The string to search\\r\\n     * @param off The offset to start searching at\\r\\n     * @param len The number of bytes to search\\r\\n     * @param needle The byte to search for\\r\\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\\r\\n     */\\r\\n    function find(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len,\\r\\n        bytes1 needle\\r\\n    ) internal pure returns (uint256) {\\r\\n        for (uint256 idx = off; idx < off + len; idx++) {\\r\\n            if (self[idx] == needle) {\\r\\n                return idx;\\r\\n            }\\r\\n        }\\r\\n        return type(uint256).max;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x1df10ca3df76235db46f65850d516bf165bcac9514aaa66876a117a3bc93c23b\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/DNSSEC.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nabstract contract DNSSEC {\\r\\n    bytes public anchors;\\r\\n\\r\\n    struct RRSetWithSignature {\\r\\n        bytes rrset;\\r\\n        bytes sig;\\r\\n    }\\r\\n\\r\\n    event AlgorithmUpdated(uint8 id, address addr);\\r\\n    event DigestUpdated(uint8 id, address addr);\\r\\n\\r\\n    function verifyRRSet(\\r\\n        RRSetWithSignature[] memory input\\r\\n    ) external view virtual returns (bytes memory rrs, uint32 inception);\\r\\n\\r\\n    function verifyRRSet(\\r\\n        RRSetWithSignature[] memory input,\\r\\n        uint256 now\\r\\n    ) public view virtual returns (bytes memory rrs, uint32 inception);\\r\\n}\\r\\n\",\"keccak256\":\"0x2fc67aef2359ab521c6c84d706df5d246d49bb1f6a605fb605272a7e976a61a2\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/DNSSECImpl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./Owned.sol\\\";\\r\\nimport \\\"./BytesUtils.sol\\\";\\r\\nimport \\\"./RRUtils.sol\\\";\\r\\nimport \\\"./DNSSEC.sol\\\";\\r\\nimport \\\"./algorithms/Algorithm.sol\\\";\\r\\nimport \\\"./digests/Digest.sol\\\";\\r\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\r\\n\\r\\n/*\\r\\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\\r\\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\\r\\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\\r\\n *       - Proofs involving wildcard names will not validate.\\r\\n *       - TTLs on records are ignored, as data is not stored persistently.\\r\\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\\r\\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\\r\\n */\\r\\ncontract DNSSECImpl is DNSSEC, Owned {\\r\\n    using Buffer for Buffer.buffer;\\r\\n    using BytesUtils for bytes;\\r\\n    using RRUtils for *;\\r\\n\\r\\n    uint16 constant DNSCLASS_IN = 1;\\r\\n\\r\\n    uint16 constant DNSTYPE_DS = 43;\\r\\n    uint16 constant DNSTYPE_DNSKEY = 48;\\r\\n\\r\\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\\r\\n\\r\\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\\r\\n    error SignatureNotValidYet(uint32 inception, uint32 now);\\r\\n    error SignatureExpired(uint32 expiration, uint32 now);\\r\\n    error InvalidClass(uint16 class);\\r\\n    error InvalidRRSet();\\r\\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\\r\\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\\r\\n    error InvalidProofType(uint16 proofType);\\r\\n    error ProofNameMismatch(bytes signerName, bytes proofName);\\r\\n    error NoMatchingProof(bytes signerName);\\r\\n\\r\\n    mapping(uint8 => Algorithm) public algorithms;\\r\\n    mapping(uint8 => Digest) public digests;\\r\\n\\r\\n    /**\\r\\n     * @dev Constructor.\\r\\n     * @param _anchors The binary format RR entries for the root DS records.\\r\\n     */\\r\\n    constructor(bytes memory _anchors) {\\r\\n        // Insert the 'trust anchors' - the key hashes that start the chain\\r\\n        // of trust for all other records.\\r\\n        anchors = _anchors;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the contract address for a signature verification algorithm.\\r\\n     *      Callable only by the owner.\\r\\n     * @param id The algorithm ID\\r\\n     * @param algo The address of the algorithm contract.\\r\\n     */\\r\\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\\r\\n        algorithms[id] = algo;\\r\\n        emit AlgorithmUpdated(id, address(algo));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the contract address for a digest verification algorithm.\\r\\n     *      Callable only by the owner.\\r\\n     * @param id The digest ID\\r\\n     * @param digest The address of the digest contract.\\r\\n     */\\r\\n    function setDigest(uint8 id, Digest digest) public owner_only {\\r\\n        digests[id] = digest;\\r\\n        emit DigestUpdated(id, address(digest));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\\r\\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\\r\\n     * @param input A list of signed RRSets.\\r\\n     * @return rrs The RRData from the last RRSet in the chain.\\r\\n     * @return inception The inception time of the signed record set.\\r\\n     */\\r\\n    function verifyRRSet(\\r\\n        RRSetWithSignature[] memory input\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (bytes memory rrs, uint32 inception)\\r\\n    {\\r\\n        return verifyRRSet(input, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\\r\\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\\r\\n     * @param input A list of signed RRSets.\\r\\n     * @param now The Unix timestamp to validate the records at.\\r\\n     * @return rrs The RRData from the last RRSet in the chain.\\r\\n     * @return inception The inception time of the signed record set.\\r\\n     */\\r\\n    function verifyRRSet(\\r\\n        RRSetWithSignature[] memory input,\\r\\n        uint256 now\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (bytes memory rrs, uint32 inception)\\r\\n    {\\r\\n        bytes memory proof = anchors;\\r\\n        for (uint256 i = 0; i < input.length; i++) {\\r\\n            RRUtils.SignedSet memory rrset = validateSignedSet(\\r\\n                input[i],\\r\\n                proof,\\r\\n                now\\r\\n            );\\r\\n            proof = rrset.data;\\r\\n            inception = rrset.inception;\\r\\n        }\\r\\n        return (proof, inception);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates an RRSet against the already trusted RR provided in `proof`.\\r\\n     *\\r\\n     * @param input The signed RR set. This is in the format described in section\\r\\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\\r\\n     *        data, followed by a series of canonicalised RR records that the signature\\r\\n     *        applies to.\\r\\n     * @param proof The DNSKEY or DS to validate the signature against.\\r\\n     * @param now The current timestamp.\\r\\n     */\\r\\n    function validateSignedSet(\\r\\n        RRSetWithSignature memory input,\\r\\n        bytes memory proof,\\r\\n        uint256 now\\r\\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\\r\\n        rrset = input.rrset.readSignedSet();\\r\\n\\r\\n        // Do some basic checks on the RRs and extract the name\\r\\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\\r\\n        if (name.labelCount(0) != rrset.labels) {\\r\\n            revert InvalidLabelCount(name, rrset.labels);\\r\\n        }\\r\\n        rrset.name = name;\\r\\n\\r\\n        // All comparisons involving the Signature Expiration and\\r\\n        // Inception fields MUST use \\\"serial number arithmetic\\\", as\\r\\n        // defined in RFC 1982\\r\\n\\r\\n        // o  The validator's notion of the current time MUST be less than or\\r\\n        //    equal to the time listed in the RRSIG RR's Expiration field.\\r\\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\\r\\n            revert SignatureExpired(rrset.expiration, uint32(now));\\r\\n        }\\r\\n\\r\\n        // o  The validator's notion of the current time MUST be greater than or\\r\\n        //    equal to the time listed in the RRSIG RR's Inception field.\\r\\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\\r\\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\\r\\n        }\\r\\n\\r\\n        // Validate the signature\\r\\n        verifySignature(name, rrset, input, proof);\\r\\n\\r\\n        return rrset;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates a set of RRs.\\r\\n     * @param rrset The RR set.\\r\\n     * @param typecovered The type covered by the RRSIG record.\\r\\n     */\\r\\n    function validateRRs(\\r\\n        RRUtils.SignedSet memory rrset,\\r\\n        uint16 typecovered\\r\\n    ) internal pure returns (bytes memory name) {\\r\\n        // Iterate over all the RRs\\r\\n        for (\\r\\n            RRUtils.RRIterator memory iter = rrset.rrs();\\r\\n            !iter.done();\\r\\n            iter.next()\\r\\n        ) {\\r\\n            // We only support class IN (Internet)\\r\\n            if (iter.class != DNSCLASS_IN) {\\r\\n                revert InvalidClass(iter.class);\\r\\n            }\\r\\n\\r\\n            if (name.length == 0) {\\r\\n                name = iter.name();\\r\\n            } else {\\r\\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\\r\\n                // repeatedly.\\r\\n                if (\\r\\n                    name.length != iter.data.nameLength(iter.offset) ||\\r\\n                    !name.equals(0, iter.data, iter.offset, name.length)\\r\\n                ) {\\r\\n                    revert InvalidRRSet();\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\\r\\n            if (iter.dnstype != typecovered) {\\r\\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs signature verification.\\r\\n     *\\r\\n     * Throws or reverts if unable to verify the record.\\r\\n     *\\r\\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\\r\\n     * @param data The original data to verify.\\r\\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\\r\\n     */\\r\\n    function verifySignature(\\r\\n        bytes memory name,\\r\\n        RRUtils.SignedSet memory rrset,\\r\\n        RRSetWithSignature memory data,\\r\\n        bytes memory proof\\r\\n    ) internal view {\\r\\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\\r\\n        //    that contains the RRset.\\r\\n        if (!name.isSubdomainOf(rrset.signerName)) {\\r\\n            revert InvalidSignerName(name, rrset.signerName);\\r\\n        }\\r\\n\\r\\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\\r\\n        // Check the proof\\r\\n        if (proofRR.dnstype == DNSTYPE_DS) {\\r\\n            verifyWithDS(rrset, data, proofRR);\\r\\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\\r\\n            verifyWithKnownKey(rrset, data, proofRR);\\r\\n        } else {\\r\\n            revert InvalidProofType(proofRR.dnstype);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to verify a signed RRSET against an already known public key.\\r\\n     * @param rrset The signed set to verify.\\r\\n     * @param data The original data the signed set was read from.\\r\\n     * @param proof The serialized DS or DNSKEY record to use as proof.\\r\\n     */\\r\\n    function verifyWithKnownKey(\\r\\n        RRUtils.SignedSet memory rrset,\\r\\n        RRSetWithSignature memory data,\\r\\n        RRUtils.RRIterator memory proof\\r\\n    ) internal view {\\r\\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\\r\\n        for (; !proof.done(); proof.next()) {\\r\\n            bytes memory proofName = proof.name();\\r\\n            if (!proofName.equals(rrset.signerName)) {\\r\\n                revert ProofNameMismatch(rrset.signerName, proofName);\\r\\n            }\\r\\n\\r\\n            bytes memory keyrdata = proof.rdata();\\r\\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\\r\\n                0,\\r\\n                keyrdata.length\\r\\n            );\\r\\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        revert NoMatchingProof(rrset.signerName);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to verify some data using a provided key and a signature.\\r\\n     * @param dnskey The dns key record to verify the signature with.\\r\\n     * @param rrset The signed RRSET being verified.\\r\\n     * @param data The original data `rrset` was decoded from.\\r\\n     * @return True iff the key verifies the signature.\\r\\n     */\\r\\n    function verifySignatureWithKey(\\r\\n        RRUtils.DNSKEY memory dnskey,\\r\\n        bytes memory keyrdata,\\r\\n        RRUtils.SignedSet memory rrset,\\r\\n        RRSetWithSignature memory data\\r\\n    ) internal view returns (bool) {\\r\\n        // TODO: Check key isn't expired, unless updating key itself\\r\\n\\r\\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\\r\\n        if (dnskey.protocol != 3) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\\r\\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\\r\\n        //   the zone's apex DNSKEY RRset.\\r\\n        if (dnskey.algorithm != rrset.algorithm) {\\r\\n            return false;\\r\\n        }\\r\\n        uint16 computedkeytag = keyrdata.computeKeytag();\\r\\n        if (computedkeytag != rrset.keytag) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\\r\\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\\r\\n        //   set.\\r\\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        Algorithm algorithm = algorithms[dnskey.algorithm];\\r\\n        if (address(algorithm) == address(0)) {\\r\\n            return false;\\r\\n        }\\r\\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\\r\\n     *      that the record\\r\\n     * @param rrset The signed set to verify.\\r\\n     * @param data The original data the signed set was read from.\\r\\n     * @param proof The serialized DS or DNSKEY record to use as proof.\\r\\n     */\\r\\n    function verifyWithDS(\\r\\n        RRUtils.SignedSet memory rrset,\\r\\n        RRSetWithSignature memory data,\\r\\n        RRUtils.RRIterator memory proof\\r\\n    ) internal view {\\r\\n        uint256 proofOffset = proof.offset;\\r\\n        for (\\r\\n            RRUtils.RRIterator memory iter = rrset.rrs();\\r\\n            !iter.done();\\r\\n            iter.next()\\r\\n        ) {\\r\\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\\r\\n                revert InvalidProofType(iter.dnstype);\\r\\n            }\\r\\n\\r\\n            bytes memory keyrdata = iter.rdata();\\r\\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\\r\\n                0,\\r\\n                keyrdata.length\\r\\n            );\\r\\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\\r\\n                // It's self-signed - look for a DS record to verify it.\\r\\n                if (\\r\\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\\r\\n                ) {\\r\\n                    return;\\r\\n                }\\r\\n                // Rewind proof iterator to the start for the next loop iteration.\\r\\n                proof.nextOffset = proofOffset;\\r\\n                proof.next();\\r\\n            }\\r\\n        }\\r\\n        revert NoMatchingProof(rrset.signerName);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to verify a key using DS records.\\r\\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\\r\\n     * @param dsrrs The DS records to use in verification.\\r\\n     * @param dnskey The dnskey to verify.\\r\\n     * @param keyrdata The RDATA section of the key.\\r\\n     * @return True if a DS record verifies this key.\\r\\n     */\\r\\n    function verifyKeyWithDS(\\r\\n        bytes memory keyname,\\r\\n        RRUtils.RRIterator memory dsrrs,\\r\\n        RRUtils.DNSKEY memory dnskey,\\r\\n        bytes memory keyrdata\\r\\n    ) internal view returns (bool) {\\r\\n        uint16 keytag = keyrdata.computeKeytag();\\r\\n        for (; !dsrrs.done(); dsrrs.next()) {\\r\\n            bytes memory proofName = dsrrs.name();\\r\\n            if (!proofName.equals(keyname)) {\\r\\n                revert ProofNameMismatch(keyname, proofName);\\r\\n            }\\r\\n\\r\\n            RRUtils.DS memory ds = dsrrs.data.readDS(\\r\\n                dsrrs.rdataOffset,\\r\\n                dsrrs.nextOffset - dsrrs.rdataOffset\\r\\n            );\\r\\n            if (ds.keytag != keytag) {\\r\\n                continue;\\r\\n            }\\r\\n            if (ds.algorithm != dnskey.algorithm) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            Buffer.buffer memory buf;\\r\\n            buf.init(keyname.length + keyrdata.length);\\r\\n            buf.append(keyname);\\r\\n            buf.append(keyrdata);\\r\\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to verify a DS record's hash value against some data.\\r\\n     * @param digesttype The digest ID from the DS record.\\r\\n     * @param data The data to digest.\\r\\n     * @param digest The digest data to check against.\\r\\n     * @return True iff the digest matches.\\r\\n     */\\r\\n    function verifyDSHash(\\r\\n        uint8 digesttype,\\r\\n        bytes memory data,\\r\\n        bytes memory digest\\r\\n    ) internal view returns (bool) {\\r\\n        if (address(digests[digesttype]) == address(0)) {\\r\\n            return false;\\r\\n        }\\r\\n        return digests[digesttype].verify(data, digest);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xe17da3d4315d438ab6b184138fdf94290b64df4b029e2366563c44a20b0b3c33\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/Owned.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Contract mixin for 'owned' contracts.\\r\\n */\\r\\ncontract Owned {\\r\\n    address public owner;\\r\\n\\r\\n    modifier owner_only() {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    function setOwner(address newOwner) public owner_only {\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xae506f08a7baec1d7a038160905d3fe9cddad57a63389f956515376e8bc20e66\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/RRUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./BytesUtils.sol\\\";\\r\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\r\\n */\\r\\nlibrary RRUtils {\\r\\n    using BytesUtils for *;\\r\\n    using Buffer for *;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\\r\\n     * @param self The byte array to read a name from.\\r\\n     * @param offset The offset to start reading at.\\r\\n     * @return The length of the DNS name at 'offset', in bytes.\\r\\n     */\\r\\n    function nameLength(\\r\\n        bytes memory self,\\r\\n        uint256 offset\\r\\n    ) internal pure returns (uint256) {\\r\\n        uint256 idx = offset;\\r\\n        while (true) {\\r\\n            assert(idx < self.length);\\r\\n            uint256 labelLen = self.readUint8(idx);\\r\\n            idx += labelLen + 1;\\r\\n            if (labelLen == 0) {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return idx - offset;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a DNS format name at the specified offset of self.\\r\\n     * @param self The byte array to read a name from.\\r\\n     * @param offset The offset to start reading at.\\r\\n     * @return ret The name.\\r\\n     */\\r\\n    function readName(\\r\\n        bytes memory self,\\r\\n        uint256 offset\\r\\n    ) internal pure returns (bytes memory ret) {\\r\\n        uint256 len = nameLength(self, offset);\\r\\n        return self.substring(offset, len);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\\r\\n     * @param self The byte array to read a name from.\\r\\n     * @param offset The offset to start reading at.\\r\\n     * @return The number of labels in the DNS name at 'offset', in bytes.\\r\\n     */\\r\\n    function labelCount(\\r\\n        bytes memory self,\\r\\n        uint256 offset\\r\\n    ) internal pure returns (uint256) {\\r\\n        uint256 count = 0;\\r\\n        while (true) {\\r\\n            assert(offset < self.length);\\r\\n            uint256 labelLen = self.readUint8(offset);\\r\\n            offset += labelLen + 1;\\r\\n            if (labelLen == 0) {\\r\\n                break;\\r\\n            }\\r\\n            count += 1;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n\\r\\n    uint256 constant RRSIG_TYPE = 0;\\r\\n    uint256 constant RRSIG_ALGORITHM = 2;\\r\\n    uint256 constant RRSIG_LABELS = 3;\\r\\n    uint256 constant RRSIG_TTL = 4;\\r\\n    uint256 constant RRSIG_EXPIRATION = 8;\\r\\n    uint256 constant RRSIG_INCEPTION = 12;\\r\\n    uint256 constant RRSIG_KEY_TAG = 16;\\r\\n    uint256 constant RRSIG_SIGNER_NAME = 18;\\r\\n\\r\\n    struct SignedSet {\\r\\n        uint16 typeCovered;\\r\\n        uint8 algorithm;\\r\\n        uint8 labels;\\r\\n        uint32 ttl;\\r\\n        uint32 expiration;\\r\\n        uint32 inception;\\r\\n        uint16 keytag;\\r\\n        bytes signerName;\\r\\n        bytes data;\\r\\n        bytes name;\\r\\n    }\\r\\n\\r\\n    function readSignedSet(\\r\\n        bytes memory data\\r\\n    ) internal pure returns (SignedSet memory self) {\\r\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\r\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\r\\n        self.labels = data.readUint8(RRSIG_LABELS);\\r\\n        self.ttl = data.readUint32(RRSIG_TTL);\\r\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\r\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\r\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\r\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\r\\n        self.data = data.substring(\\r\\n            RRSIG_SIGNER_NAME + self.signerName.length,\\r\\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function rrs(\\r\\n        SignedSet memory rrset\\r\\n    ) internal pure returns (RRIterator memory) {\\r\\n        return iterateRRs(rrset.data, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev An iterator over resource records.\\r\\n     */\\r\\n    struct RRIterator {\\r\\n        bytes data;\\r\\n        uint256 offset;\\r\\n        uint16 dnstype;\\r\\n        uint16 class;\\r\\n        uint32 ttl;\\r\\n        uint256 rdataOffset;\\r\\n        uint256 nextOffset;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Begins iterating over resource records.\\r\\n     * @param self The byte string to read from.\\r\\n     * @param offset The offset to start reading at.\\r\\n     * @return ret An iterator object.\\r\\n     */\\r\\n    function iterateRRs(\\r\\n        bytes memory self,\\r\\n        uint256 offset\\r\\n    ) internal pure returns (RRIterator memory ret) {\\r\\n        ret.data = self;\\r\\n        ret.nextOffset = offset;\\r\\n        next(ret);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true iff there are more RRs to iterate.\\r\\n     * @param iter The iterator to check.\\r\\n     * @return True iff the iterator has finished.\\r\\n     */\\r\\n    function done(RRIterator memory iter) internal pure returns (bool) {\\r\\n        return iter.offset >= iter.data.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves the iterator to the next resource record.\\r\\n     * @param iter The iterator to advance.\\r\\n     */\\r\\n    function next(RRIterator memory iter) internal pure {\\r\\n        iter.offset = iter.nextOffset;\\r\\n        if (iter.offset >= iter.data.length) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Skip the name\\r\\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\\r\\n\\r\\n        // Read type, class, and ttl\\r\\n        iter.dnstype = iter.data.readUint16(off);\\r\\n        off += 2;\\r\\n        iter.class = iter.data.readUint16(off);\\r\\n        off += 2;\\r\\n        iter.ttl = iter.data.readUint32(off);\\r\\n        off += 4;\\r\\n\\r\\n        // Read the rdata\\r\\n        uint256 rdataLength = iter.data.readUint16(off);\\r\\n        off += 2;\\r\\n        iter.rdataOffset = off;\\r\\n        iter.nextOffset = off + rdataLength;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the current record.\\r\\n     * @param iter The iterator.\\r\\n     * @return A new bytes object containing the owner name from the RR.\\r\\n     */\\r\\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\\r\\n        return\\r\\n            iter.data.substring(\\r\\n                iter.offset,\\r\\n                nameLength(iter.data, iter.offset)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the rdata portion of the current record.\\r\\n     * @param iter The iterator.\\r\\n     * @return A new bytes object containing the RR's RDATA.\\r\\n     */\\r\\n    function rdata(\\r\\n        RRIterator memory iter\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        return\\r\\n            iter.data.substring(\\r\\n                iter.rdataOffset,\\r\\n                iter.nextOffset - iter.rdataOffset\\r\\n            );\\r\\n    }\\r\\n\\r\\n    uint256 constant DNSKEY_FLAGS = 0;\\r\\n    uint256 constant DNSKEY_PROTOCOL = 2;\\r\\n    uint256 constant DNSKEY_ALGORITHM = 3;\\r\\n    uint256 constant DNSKEY_PUBKEY = 4;\\r\\n\\r\\n    struct DNSKEY {\\r\\n        uint16 flags;\\r\\n        uint8 protocol;\\r\\n        uint8 algorithm;\\r\\n        bytes publicKey;\\r\\n    }\\r\\n\\r\\n    function readDNSKEY(\\r\\n        bytes memory data,\\r\\n        uint256 offset,\\r\\n        uint256 length\\r\\n    ) internal pure returns (DNSKEY memory self) {\\r\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\r\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\r\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\r\\n        self.publicKey = data.substring(\\r\\n            offset + DNSKEY_PUBKEY,\\r\\n            length - DNSKEY_PUBKEY\\r\\n        );\\r\\n    }\\r\\n\\r\\n    uint256 constant DS_KEY_TAG = 0;\\r\\n    uint256 constant DS_ALGORITHM = 2;\\r\\n    uint256 constant DS_DIGEST_TYPE = 3;\\r\\n    uint256 constant DS_DIGEST = 4;\\r\\n\\r\\n    struct DS {\\r\\n        uint16 keytag;\\r\\n        uint8 algorithm;\\r\\n        uint8 digestType;\\r\\n        bytes digest;\\r\\n    }\\r\\n\\r\\n    function readDS(\\r\\n        bytes memory data,\\r\\n        uint256 offset,\\r\\n        uint256 length\\r\\n    ) internal pure returns (DS memory self) {\\r\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\r\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\r\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\r\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\r\\n    }\\r\\n\\r\\n    function isSubdomainOf(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        uint256 off = 0;\\r\\n        uint256 counts = labelCount(self, 0);\\r\\n        uint256 othercounts = labelCount(other, 0);\\r\\n\\r\\n        while (counts > othercounts) {\\r\\n            off = progress(self, off);\\r\\n            counts--;\\r\\n        }\\r\\n\\r\\n        return self.equals(off, other, 0);\\r\\n    }\\r\\n\\r\\n    function compareNames(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (int256) {\\r\\n        if (self.equals(other)) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 off;\\r\\n        uint256 otheroff;\\r\\n        uint256 prevoff;\\r\\n        uint256 otherprevoff;\\r\\n        uint256 counts = labelCount(self, 0);\\r\\n        uint256 othercounts = labelCount(other, 0);\\r\\n\\r\\n        // Keep removing labels from the front of the name until both names are equal length\\r\\n        while (counts > othercounts) {\\r\\n            prevoff = off;\\r\\n            off = progress(self, off);\\r\\n            counts--;\\r\\n        }\\r\\n\\r\\n        while (othercounts > counts) {\\r\\n            otherprevoff = otheroff;\\r\\n            otheroff = progress(other, otheroff);\\r\\n            othercounts--;\\r\\n        }\\r\\n\\r\\n        // Compare the last nonequal labels to each other\\r\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\r\\n            prevoff = off;\\r\\n            off = progress(self, off);\\r\\n            otherprevoff = otheroff;\\r\\n            otheroff = progress(other, otheroff);\\r\\n            counts -= 1;\\r\\n        }\\r\\n\\r\\n        if (off == 0) {\\r\\n            return -1;\\r\\n        }\\r\\n        if (otheroff == 0) {\\r\\n            return 1;\\r\\n        }\\r\\n\\r\\n        return\\r\\n            self.compare(\\r\\n                prevoff + 1,\\r\\n                self.readUint8(prevoff),\\r\\n                other,\\r\\n                otherprevoff + 1,\\r\\n                other.readUint8(otherprevoff)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Compares two serial numbers using RFC1982 serial number math.\\r\\n     */\\r\\n    function serialNumberGte(\\r\\n        uint32 i1,\\r\\n        uint32 i2\\r\\n    ) internal pure returns (bool) {\\r\\n        unchecked {\\r\\n            return int32(i1) - int32(i2) >= 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function progress(\\r\\n        bytes memory body,\\r\\n        uint256 off\\r\\n    ) internal pure returns (uint256) {\\r\\n        return off + 1 + body.readUint8(off);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Computes the keytag for a chunk of data.\\r\\n     * @param data The data to compute a keytag for.\\r\\n     * @return The computed key tag.\\r\\n     */\\r\\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\\r\\n        /* This function probably deserves some explanation.\\r\\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\\r\\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\\r\\n         *\\r\\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\\r\\n         *         uint ac;\\r\\n         *         for (uint i = 0; i < data.length; i++) {\\r\\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\\r\\n         *         }\\r\\n         *         return uint16(ac + (ac >> 16));\\r\\n         *     }\\r\\n         *\\r\\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\\r\\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\\r\\n         * large words work in our favour.\\r\\n         *\\r\\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\\r\\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\\r\\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\\r\\n         * effectively summing 16 different numbers with each EVM ADD opcode.\\r\\n         *\\r\\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\\r\\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\\r\\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\\r\\n         * and the remaining sums can be done just on ac1.\\r\\n         */\\r\\n        unchecked {\\r\\n            require(data.length <= 8192, \\\"Long keys not permitted\\\");\\r\\n            uint256 ac1;\\r\\n            uint256 ac2;\\r\\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\\r\\n                uint256 word;\\r\\n                assembly {\\r\\n                    word := mload(add(add(data, 32), i))\\r\\n                }\\r\\n                if (i + 32 > data.length) {\\r\\n                    uint256 unused = 256 - (data.length - i) * 8;\\r\\n                    word = (word >> unused) << unused;\\r\\n                }\\r\\n                ac1 +=\\r\\n                    (word &\\r\\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\\r\\n                    8;\\r\\n                ac2 += (word &\\r\\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\\r\\n            }\\r\\n            ac1 =\\r\\n                (ac1 &\\r\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\r\\n                ((ac1 &\\r\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\r\\n                    16);\\r\\n            ac2 =\\r\\n                (ac2 &\\r\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\r\\n                ((ac2 &\\r\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\r\\n                    16);\\r\\n            ac1 = (ac1 << 8) + ac2;\\r\\n            ac1 =\\r\\n                (ac1 &\\r\\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\\r\\n                ((ac1 &\\r\\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\\r\\n                    32);\\r\\n            ac1 =\\r\\n                (ac1 &\\r\\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\\r\\n                ((ac1 &\\r\\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\\r\\n                    64);\\r\\n            ac1 =\\r\\n                (ac1 &\\r\\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\\r\\n                (ac1 >> 128);\\r\\n            ac1 += (ac1 >> 16) & 0xFFFF;\\r\\n            return uint16(ac1);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xde34fecd276a3e991d5f2f72c3e868e915a2d2393ea5f72e31bb448cd1c51ffd\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/algorithms/Algorithm.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\\r\\n */\\r\\ninterface Algorithm {\\r\\n    /**\\r\\n     * @dev Verifies a signature.\\r\\n     * @param key The public key to verify with.\\r\\n     * @param data The signed data to verify.\\r\\n     * @param signature The signature to verify.\\r\\n     * @return True iff the signature is valid.\\r\\n     */\\r\\n    function verify(\\r\\n        bytes calldata key,\\r\\n        bytes calldata data,\\r\\n        bytes calldata signature\\r\\n    ) external view virtual returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x46b85cb958e6a339bb58228c624ad69a5dbe5310921c5b408c47b99fd5c352f3\",\"license\":\"MIT\"},\"contracts/dnssec-oracle/digests/Digest.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev An interface for contracts implementing a DNSSEC digest.\\r\\n */\\r\\ninterface Digest {\\r\\n    /**\\r\\n     * @dev Verifies a cryptographic hash.\\r\\n     * @param data The data to hash.\\r\\n     * @param hash The hash to compare to.\\r\\n     * @return True iff the hashed data matches the provided hash value.\\r\\n     */\\r\\n    function verify(\\r\\n        bytes calldata data,\\r\\n        bytes calldata hash\\r\\n    ) external pure virtual returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x763f01f822751cbf1968f4b195b8c707092d257cd7dfce0fcbb0afa068ee8207\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506040516200205638038062002056833981016040819052620000349162000072565b600180546001600160a01b031916331790556000620000548282620001d6565b5050620002a2565b634e487b7160e01b600052604160045260246000fd5b600060208083850312156200008657600080fd5b82516001600160401b03808211156200009e57600080fd5b818501915085601f830112620000b357600080fd5b815181811115620000c857620000c86200005c565b604051601f8201601f19908116603f01168101908382118183101715620000f357620000f36200005c565b8160405282815288868487010111156200010c57600080fd5b600093505b8284101562000130578484018601518185018701529285019262000111565b600086848301015280965050505050505092915050565b600181811c908216806200015c57607f821691505b6020821081036200017d57634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620001d157600081815260208120601f850160051c81016020861015620001ac5750805b601f850160051c820191505b81811015620001cd57828155600101620001b8565b5050505b505050565b81516001600160401b03811115620001f257620001f26200005c565b6200020a8162000203845462000147565b8462000183565b602080601f831160018114620002425760008415620002295750858301515b600019600386901b1c1916600185901b178555620001cd565b600085815260208120601f198616915b82811015620002735788860151825594840194600190910190840162000252565b5085821015620002925787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b611da480620002b26000396000f3fe608060405234801561001057600080fd5b50600436106100a35760003560e01c806373cc48a61161007657806398d35f201161005b57806398d35f2014610161578063bdf95fef14610176578063c327deef1461018957600080fd5b806373cc48a61461010d5780638da5cb5b1461014e57600080fd5b8063020ed8d3146100a857806313af4035146100bd57806328e7677d146100d0578063440f3d42146100e3575b600080fd5b6100bb6100b6366004611871565b6101b2565b005b6100bb6100cb3660046118a8565b610241565b6100bb6100de366004611871565b610287565b6100f66100f1366004611a9f565b61030e565b604051610104929190611b2a565b60405180910390f35b61013661011b366004611b52565b6003602052600090815260409020546001600160a01b031681565b6040516001600160a01b039091168152602001610104565b600154610136906001600160a01b031681565b610169610400565b6040516101049190611b6d565b6100f6610184366004611b80565b61048e565b610136610197366004611b52565b6002602052600090815260409020546001600160a01b031681565b6001546001600160a01b031633146101c957600080fd5b60ff8216600081815260026020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0386169081179091558251938452908301527ff73c3c226af96b7f1ba666a21b3ceaf2be3ee6a365e3178fd9cd1eaae0075aa891015b60405180910390a15050565b6001546001600160a01b0316331461025857600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6001546001600160a01b0316331461029e57600080fd5b60ff8216600081815260036020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0386169081179091558251938452908301527f2fcc274c3b72dd483ab201bfa87295e3817e8b9b10693219873b722ca1af00c79101610235565b60606000806000805461032090611bb5565b80601f016020809104026020016040519081016040528092919081815260200182805461034c90611bb5565b80156103995780601f1061036e57610100808354040283529160200191610399565b820191906000526020600020905b81548152906001019060200180831161037c57829003601f168201915b5050505050905060005b85518110156103f65760006103d28783815181106103c3576103c3611bef565b602002602001015184886104a5565b61010081015160a090910151945092508190506103ee81611c1b565b9150506103a3565b5091509250929050565b6000805461040d90611bb5565b80601f016020809104026020016040519081016040528092919081815260200182805461043990611bb5565b80156104865780601f1061045b57610100808354040283529160200191610486565b820191906000526020600020905b81548152906001019060200180831161046957829003601f168201915b505050505081565b6060600061049c834261030e565b91509150915091565b604080516101408101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c082019290925260e081018290526101008101829052610120810191909152835161050390610647565b90506000610515828360000151610789565b604083015190915060ff1661052b8260006108e6565b14610573578082604001516040517fe861b2bd00000000000000000000000000000000000000000000000000000000815260040161056a929190611c34565b60405180910390fd5b6101208201819052608082015160009084900360030b12156105d75760808201516040517fa784f87e00000000000000000000000000000000000000000000000000000000815263ffffffff9182166004820152908416602482015260440161056a565b60a0820151600090840360030b12156106325760a08201516040517fbd41036a00000000000000000000000000000000000000000000000000000000815263ffffffff9182166004820152908416602482015260440161056a565b61063e8183878761094c565b505b9392505050565b604080516101408101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e082018190526101008201819052610120820152906106a2908390610a16565b61ffff1681526106b3826002610a3e565b60ff1660208201526106c6826003610a3e565b60ff1660408201526106d9826004610a62565b63ffffffff90811660608301526106f5908390600890610a6216565b63ffffffff9081166080830152610711908390600c90610a6216565b63ffffffff90811660a083015261072d908390601090610a1616565b61ffff1660c0820152610741826012610a8c565b60e082018190525161077e90610758906012611c59565b8260e00151516012855161076c9190611c6c565b6107769190611c6c565b849190610aaf565b610100820152919050565b6060600061079684610b31565b90505b805151602082015110156108df57606081015161ffff166001146107f55760608101516040517f98a5f31a00000000000000000000000000000000000000000000000000000000815261ffff909116600482015260240161056a565b815160000361080e5761080781610b8f565b9150610878565b6020810151815161081e91610bb0565b8251141580610841575080516020820151835161083f928592600092610c0a565b155b15610878576040517fcbceee6f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8261ffff16816040015161ffff16146108d15760408082015190517fa6ff8a8a00000000000000000000000000000000000000000000000000000000815261ffff9182166004820152908416602482015260440161056a565b6108da81610c2d565b610799565b5092915050565b6000805b835183106108fa576108fa611c7f565b60006109068585610a3e565b60ff169050610916816001611c59565b6109209085611c59565b9350806000036109305750610943565b61093b600183611c59565b9150506108ea565b90505b92915050565b60e083015161095c908590610d15565b6109995760e08301516040517feaafc59b00000000000000000000000000000000000000000000000000000000815261056a918691600401611c95565b60006109a58282610d72565b9050602b61ffff16816040015161ffff16036109cb576109c6848483610dd3565b610a0f565b603061ffff16816040015161ffff16036109ea576109c6848483610ec0565b60408082015190516361529e8760e01b815261ffff909116600482015260240161056a565b5050505050565b8151600090610a26836002611c59565b1115610a3157600080fd5b50016002015161ffff1690565b6000828281518110610a5257610a52611bef565b016020015160f81c905092915050565b8151600090610a72836004611c59565b1115610a7d57600080fd5b50016004015163ffffffff1690565b60606000610a9a8484610bb0565b9050610aa7848483610aaf565b949350505050565b8251606090610abe8385611c59565b1115610ac957600080fd5b60008267ffffffffffffffff811115610ae457610ae46118c5565b6040519080825280601f01601f191660200182016040528015610b0e576020820181803683370190505b50905060208082019086860101610b26828287610f88565b509095945050505050565b610b7f6040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b6109468261010001516000610d72565b6020810151815160609161094691610ba79082610bb0565b84519190610aaf565b6000815b83518110610bc457610bc4611c7f565b6000610bd08583610a3e565b60ff169050610be0816001611c59565b610bea9083611c59565b915080600003610bfa5750610c00565b50610bb4565b610aa78382611c6c565b6000610c17848484610fde565b610c22878785610fde565b149695505050505050565b60c08101516020820181905281515111610c445750565b6000610c5882600001518360200151610bb0565b8260200151610c679190611c59565b8251909150610c769082610a16565b61ffff166040830152610c8a600282611c59565b8251909150610c999082610a16565b61ffff166060830152610cad600282611c59565b8251909150610cbc9082610a62565b63ffffffff166080830152610cd2600482611c59565b8251909150600090610ce49083610a16565b61ffff169050610cf5600283611c59565b60a084018190529150610d088183611c59565b60c0909301929092525050565b60008080610d2385826108e6565b90506000610d328560006108e6565b90505b80821115610d5b57610d478684611002565b925081610d5381611cc3565b925050610d35565b610d688684876000611026565b9695505050505050565b610dc06040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c0810182905261094681610c2d565b60208101516000610de385610b31565b90505b80515160208201511015610ea057604081015161ffff16603014610e295760408082015190516361529e8760e01b815261ffff909116600482015260240161056a565b6000610e348261105b565b90506000610e4f60008351846110779092919063ffffffff16565b9050610e5d81838989611115565b15610e9057610e728760e00151868385611254565b15610e805750505050505050565b60c08501849052610e9085610c2d565b5050610e9b81610c2d565b610de6565b508360e001516040516306cde0f360e01b815260040161056a9190611b6d565b80515160208201511015610f69576000610ed982610b8f565b9050610ef28460e001518261139190919063ffffffff16565b610f17578360e0015181604051636b80573f60e11b815260040161056a929190611c95565b6000610f228361105b565b90506000610f3d60008351846110779092919063ffffffff16565b9050610f4b81838888611115565b15610f5857505050505050565b505050610f6481610c2d565b610ec0565b8260e001516040516306cde0f360e01b815260040161056a9190611b6d565b60208110610fc05781518352610f9f602084611c59565b9250610fac602083611c59565b9150610fb9602082611c6c565b9050610f88565b905182516020929092036101000a6000190180199091169116179052565b8251600090610fed8385611c59565b1115610ff857600080fd5b5091016020012090565b600061100e8383610a3e565b60ff1661101c836001611c59565b6109439190611c59565b600061103f838384865161103a9190611c6c565b610fde565b611051868687895161103a9190611c6c565b1495945050505050565b60a081015160c082015160609161094691610ba7908290611c6c565b60408051608081018252600080825260208201819052918101919091526060808201526110af6110a8600085611c59565b8590610a16565b61ffff1681526110ca6110c3600285611c59565b8590610a3e565b60ff1660208201526110e06110c3600385611c59565b60ff1660408201526111096110f6600485611c59565b611101600485611c6c565b869190610aaf565b60608201529392505050565b6000846020015160ff1660031461112e57506000610aa7565b826020015160ff16856040015160ff161461114b57506000610aa7565b6000611156856113af565b90508360c0015161ffff168161ffff1614611175576000915050610aa7565b85516101001660000361118c576000915050610aa7565b60408087015160ff166000908152600260205220546001600160a01b0316806111ba57600092505050610aa7565b835160208501516040517fde8f50a10000000000000000000000000000000000000000000000000000000081526001600160a01b0384169263de8f50a192611208928b929190600401611cda565b602060405180830381865afa158015611225573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112499190611d13565b979650505050505050565b600080611260836113af565b90505b8451516020860151101561138557600061127c86610b8f565b90506112888188611391565b6112a9578681604051636b80573f60e11b815260040161056a929190611c95565b60a086015160c08701516000916112ce916112c5908290611c6c565b89519190611077565b90508261ffff16816000015161ffff16146112ea575050611377565b856040015160ff16816020015160ff1614611306575050611377565b60408051808201909152606081526000602082015261133386518a5161132c9190611c59565b82906115f3565b5061133e818a61166a565b50611349818761166a565b5061136182604001518260000151846060015161168b565b15611373576001945050505050610aa7565b5050505b61138085610c2d565b611263565b50600095945050505050565b60008151835114801561094357506109438360008460008751610c0a565b60006120008251111561141e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4c6f6e67206b657973206e6f74207065726d6974746564000000000000000000604482015260640161056a565b60008060005b8451601f0181101561149357600081602087010151905085518260200111156114595785518290036008026101000390811c901b5b7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff600882901c81169490940193169190910190602001611424565b506010827fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c827dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff160191506010817fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff1601905080600883901b0191506020827fffffffff00000000ffffffff00000000ffffffff00000000ffffffff0000000016901c827bffffffff00000000ffffffff00000000ffffffff00000000ffffffff160191506040827fffffffffffffffff0000000000000000ffffffffffffffff000000000000000016901c8277ffffffffffffffff0000000000000000ffffffffffffffff16019150608082901c826fffffffffffffffffffffffffffffffff16019150601082901c61ffff16820191508192505050919050565b604080518082019091526060815260006020820152611613602083611d35565b1561163b57611623602083611d35565b61162e906020611c6c565b6116389083611c59565b91505b60208084018390526040518085526000815290818401018181101561165f57600080fd5b604052509192915050565b60408051808201909152606081526000602082015261094383838451611750565b60ff83166000908152600360205260408120546001600160a01b03166116b357506000610640565b60ff8416600090815260036020526040908190205490517ff7e83aee0000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063f7e83aee9061170f9086908690600401611c95565b602060405180830381865afa15801561172c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa79190611d13565b604080518082019091526060815260006020820152825182111561177357600080fd5b83515160006117828483611c59565b905085602001518111156117a4576117a48661179f836002611d57565b611826565b8551805183820160200191600091808511156117be578482525b505050602086015b602086106117fe57805182526117dd602083611c59565b91506117ea602082611c59565b90506117f7602087611c6c565b95506117c6565b51815160001960208890036101000a0190811690199190911617905250849150509392505050565b815161183283836115f3565b5061183d838261166a565b50505050565b803560ff8116811461185457600080fd5b919050565b6001600160a01b038116811461186e57600080fd5b50565b6000806040838503121561188457600080fd5b61188d83611843565b9150602083013561189d81611859565b809150509250929050565b6000602082840312156118ba57600080fd5b813561094381611859565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156118fe576118fe6118c5565b60405290565b604051601f8201601f1916810167ffffffffffffffff8111828210171561192d5761192d6118c5565b604052919050565b600082601f83011261194657600080fd5b813567ffffffffffffffff811115611960576119606118c5565b611973601f8201601f1916602001611904565b81815284602083860101111561198857600080fd5b816020850160208301376000918101602001919091529392505050565b600082601f8301126119b657600080fd5b8135602067ffffffffffffffff808311156119d3576119d36118c5565b8260051b6119e2838201611904565b93845285810183019383810190888611156119fc57600080fd5b84880192505b85831015611a9357823584811115611a1a5760008081fd5b88016040818b03601f1901811315611a325760008081fd5b611a3a6118db565b8783013587811115611a4c5760008081fd5b611a5a8d8a83870101611935565b825250908201359086821115611a705760008081fd5b611a7e8c8984860101611935565b81890152845250509184019190840190611a02565b98975050505050505050565b60008060408385031215611ab257600080fd5b823567ffffffffffffffff811115611ac957600080fd5b611ad5858286016119a5565b95602094909401359450505050565b6000815180845260005b81811015611b0a57602081850181015186830182015201611aee565b506000602082860101526020601f19601f83011685010191505092915050565b604081526000611b3d6040830185611ae4565b905063ffffffff831660208301529392505050565b600060208284031215611b6457600080fd5b61094382611843565b6020815260006109436020830184611ae4565b600060208284031215611b9257600080fd5b813567ffffffffffffffff811115611ba957600080fd5b610aa7848285016119a5565b600181811c90821680611bc957607f821691505b602082108103611be957634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060018201611c2d57611c2d611c05565b5060010190565b604081526000611c476040830185611ae4565b905060ff831660208301529392505050565b8082018082111561094657610946611c05565b8181038181111561094657610946611c05565b634e487b7160e01b600052600160045260246000fd5b604081526000611ca86040830185611ae4565b8281036020840152611cba8185611ae4565b95945050505050565b600081611cd257611cd2611c05565b506000190190565b606081526000611ced6060830186611ae4565b8281036020840152611cff8186611ae4565b90508281036040840152610d688185611ae4565b600060208284031215611d2557600080fd5b8151801515811461094357600080fd5b600082611d5257634e487b7160e01b600052601260045260246000fd5b500690565b808202811582820484141761094657610946611c0556fea2646970667358221220e740b7c25fcb6a8d96cd167fb260ec85c1f5a0dcc05547043e12722d22c99b9a64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a35760003560e01c806373cc48a61161007657806398d35f201161005b57806398d35f2014610161578063bdf95fef14610176578063c327deef1461018957600080fd5b806373cc48a61461010d5780638da5cb5b1461014e57600080fd5b8063020ed8d3146100a857806313af4035146100bd57806328e7677d146100d0578063440f3d42146100e3575b600080fd5b6100bb6100b6366004611871565b6101b2565b005b6100bb6100cb3660046118a8565b610241565b6100bb6100de366004611871565b610287565b6100f66100f1366004611a9f565b61030e565b604051610104929190611b2a565b60405180910390f35b61013661011b366004611b52565b6003602052600090815260409020546001600160a01b031681565b6040516001600160a01b039091168152602001610104565b600154610136906001600160a01b031681565b610169610400565b6040516101049190611b6d565b6100f6610184366004611b80565b61048e565b610136610197366004611b52565b6002602052600090815260409020546001600160a01b031681565b6001546001600160a01b031633146101c957600080fd5b60ff8216600081815260026020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0386169081179091558251938452908301527ff73c3c226af96b7f1ba666a21b3ceaf2be3ee6a365e3178fd9cd1eaae0075aa891015b60405180910390a15050565b6001546001600160a01b0316331461025857600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6001546001600160a01b0316331461029e57600080fd5b60ff8216600081815260036020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0386169081179091558251938452908301527f2fcc274c3b72dd483ab201bfa87295e3817e8b9b10693219873b722ca1af00c79101610235565b60606000806000805461032090611bb5565b80601f016020809104026020016040519081016040528092919081815260200182805461034c90611bb5565b80156103995780601f1061036e57610100808354040283529160200191610399565b820191906000526020600020905b81548152906001019060200180831161037c57829003601f168201915b5050505050905060005b85518110156103f65760006103d28783815181106103c3576103c3611bef565b602002602001015184886104a5565b61010081015160a090910151945092508190506103ee81611c1b565b9150506103a3565b5091509250929050565b6000805461040d90611bb5565b80601f016020809104026020016040519081016040528092919081815260200182805461043990611bb5565b80156104865780601f1061045b57610100808354040283529160200191610486565b820191906000526020600020905b81548152906001019060200180831161046957829003601f168201915b505050505081565b6060600061049c834261030e565b91509150915091565b604080516101408101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c082019290925260e081018290526101008101829052610120810191909152835161050390610647565b90506000610515828360000151610789565b604083015190915060ff1661052b8260006108e6565b14610573578082604001516040517fe861b2bd00000000000000000000000000000000000000000000000000000000815260040161056a929190611c34565b60405180910390fd5b6101208201819052608082015160009084900360030b12156105d75760808201516040517fa784f87e00000000000000000000000000000000000000000000000000000000815263ffffffff9182166004820152908416602482015260440161056a565b60a0820151600090840360030b12156106325760a08201516040517fbd41036a00000000000000000000000000000000000000000000000000000000815263ffffffff9182166004820152908416602482015260440161056a565b61063e8183878761094c565b505b9392505050565b604080516101408101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e082018190526101008201819052610120820152906106a2908390610a16565b61ffff1681526106b3826002610a3e565b60ff1660208201526106c6826003610a3e565b60ff1660408201526106d9826004610a62565b63ffffffff90811660608301526106f5908390600890610a6216565b63ffffffff9081166080830152610711908390600c90610a6216565b63ffffffff90811660a083015261072d908390601090610a1616565b61ffff1660c0820152610741826012610a8c565b60e082018190525161077e90610758906012611c59565b8260e00151516012855161076c9190611c6c565b6107769190611c6c565b849190610aaf565b610100820152919050565b6060600061079684610b31565b90505b805151602082015110156108df57606081015161ffff166001146107f55760608101516040517f98a5f31a00000000000000000000000000000000000000000000000000000000815261ffff909116600482015260240161056a565b815160000361080e5761080781610b8f565b9150610878565b6020810151815161081e91610bb0565b8251141580610841575080516020820151835161083f928592600092610c0a565b155b15610878576040517fcbceee6f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8261ffff16816040015161ffff16146108d15760408082015190517fa6ff8a8a00000000000000000000000000000000000000000000000000000000815261ffff9182166004820152908416602482015260440161056a565b6108da81610c2d565b610799565b5092915050565b6000805b835183106108fa576108fa611c7f565b60006109068585610a3e565b60ff169050610916816001611c59565b6109209085611c59565b9350806000036109305750610943565b61093b600183611c59565b9150506108ea565b90505b92915050565b60e083015161095c908590610d15565b6109995760e08301516040517feaafc59b00000000000000000000000000000000000000000000000000000000815261056a918691600401611c95565b60006109a58282610d72565b9050602b61ffff16816040015161ffff16036109cb576109c6848483610dd3565b610a0f565b603061ffff16816040015161ffff16036109ea576109c6848483610ec0565b60408082015190516361529e8760e01b815261ffff909116600482015260240161056a565b5050505050565b8151600090610a26836002611c59565b1115610a3157600080fd5b50016002015161ffff1690565b6000828281518110610a5257610a52611bef565b016020015160f81c905092915050565b8151600090610a72836004611c59565b1115610a7d57600080fd5b50016004015163ffffffff1690565b60606000610a9a8484610bb0565b9050610aa7848483610aaf565b949350505050565b8251606090610abe8385611c59565b1115610ac957600080fd5b60008267ffffffffffffffff811115610ae457610ae46118c5565b6040519080825280601f01601f191660200182016040528015610b0e576020820181803683370190505b50905060208082019086860101610b26828287610f88565b509095945050505050565b610b7f6040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b6109468261010001516000610d72565b6020810151815160609161094691610ba79082610bb0565b84519190610aaf565b6000815b83518110610bc457610bc4611c7f565b6000610bd08583610a3e565b60ff169050610be0816001611c59565b610bea9083611c59565b915080600003610bfa5750610c00565b50610bb4565b610aa78382611c6c565b6000610c17848484610fde565b610c22878785610fde565b149695505050505050565b60c08101516020820181905281515111610c445750565b6000610c5882600001518360200151610bb0565b8260200151610c679190611c59565b8251909150610c769082610a16565b61ffff166040830152610c8a600282611c59565b8251909150610c999082610a16565b61ffff166060830152610cad600282611c59565b8251909150610cbc9082610a62565b63ffffffff166080830152610cd2600482611c59565b8251909150600090610ce49083610a16565b61ffff169050610cf5600283611c59565b60a084018190529150610d088183611c59565b60c0909301929092525050565b60008080610d2385826108e6565b90506000610d328560006108e6565b90505b80821115610d5b57610d478684611002565b925081610d5381611cc3565b925050610d35565b610d688684876000611026565b9695505050505050565b610dc06040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c0810182905261094681610c2d565b60208101516000610de385610b31565b90505b80515160208201511015610ea057604081015161ffff16603014610e295760408082015190516361529e8760e01b815261ffff909116600482015260240161056a565b6000610e348261105b565b90506000610e4f60008351846110779092919063ffffffff16565b9050610e5d81838989611115565b15610e9057610e728760e00151868385611254565b15610e805750505050505050565b60c08501849052610e9085610c2d565b5050610e9b81610c2d565b610de6565b508360e001516040516306cde0f360e01b815260040161056a9190611b6d565b80515160208201511015610f69576000610ed982610b8f565b9050610ef28460e001518261139190919063ffffffff16565b610f17578360e0015181604051636b80573f60e11b815260040161056a929190611c95565b6000610f228361105b565b90506000610f3d60008351846110779092919063ffffffff16565b9050610f4b81838888611115565b15610f5857505050505050565b505050610f6481610c2d565b610ec0565b8260e001516040516306cde0f360e01b815260040161056a9190611b6d565b60208110610fc05781518352610f9f602084611c59565b9250610fac602083611c59565b9150610fb9602082611c6c565b9050610f88565b905182516020929092036101000a6000190180199091169116179052565b8251600090610fed8385611c59565b1115610ff857600080fd5b5091016020012090565b600061100e8383610a3e565b60ff1661101c836001611c59565b6109439190611c59565b600061103f838384865161103a9190611c6c565b610fde565b611051868687895161103a9190611c6c565b1495945050505050565b60a081015160c082015160609161094691610ba7908290611c6c565b60408051608081018252600080825260208201819052918101919091526060808201526110af6110a8600085611c59565b8590610a16565b61ffff1681526110ca6110c3600285611c59565b8590610a3e565b60ff1660208201526110e06110c3600385611c59565b60ff1660408201526111096110f6600485611c59565b611101600485611c6c565b869190610aaf565b60608201529392505050565b6000846020015160ff1660031461112e57506000610aa7565b826020015160ff16856040015160ff161461114b57506000610aa7565b6000611156856113af565b90508360c0015161ffff168161ffff1614611175576000915050610aa7565b85516101001660000361118c576000915050610aa7565b60408087015160ff166000908152600260205220546001600160a01b0316806111ba57600092505050610aa7565b835160208501516040517fde8f50a10000000000000000000000000000000000000000000000000000000081526001600160a01b0384169263de8f50a192611208928b929190600401611cda565b602060405180830381865afa158015611225573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112499190611d13565b979650505050505050565b600080611260836113af565b90505b8451516020860151101561138557600061127c86610b8f565b90506112888188611391565b6112a9578681604051636b80573f60e11b815260040161056a929190611c95565b60a086015160c08701516000916112ce916112c5908290611c6c565b89519190611077565b90508261ffff16816000015161ffff16146112ea575050611377565b856040015160ff16816020015160ff1614611306575050611377565b60408051808201909152606081526000602082015261133386518a5161132c9190611c59565b82906115f3565b5061133e818a61166a565b50611349818761166a565b5061136182604001518260000151846060015161168b565b15611373576001945050505050610aa7565b5050505b61138085610c2d565b611263565b50600095945050505050565b60008151835114801561094357506109438360008460008751610c0a565b60006120008251111561141e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4c6f6e67206b657973206e6f74207065726d6974746564000000000000000000604482015260640161056a565b60008060005b8451601f0181101561149357600081602087010151905085518260200111156114595785518290036008026101000390811c901b5b7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff600882901c81169490940193169190910190602001611424565b506010827fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c827dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff160191506010817fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff1601905080600883901b0191506020827fffffffff00000000ffffffff00000000ffffffff00000000ffffffff0000000016901c827bffffffff00000000ffffffff00000000ffffffff00000000ffffffff160191506040827fffffffffffffffff0000000000000000ffffffffffffffff000000000000000016901c8277ffffffffffffffff0000000000000000ffffffffffffffff16019150608082901c826fffffffffffffffffffffffffffffffff16019150601082901c61ffff16820191508192505050919050565b604080518082019091526060815260006020820152611613602083611d35565b1561163b57611623602083611d35565b61162e906020611c6c565b6116389083611c59565b91505b60208084018390526040518085526000815290818401018181101561165f57600080fd5b604052509192915050565b60408051808201909152606081526000602082015261094383838451611750565b60ff83166000908152600360205260408120546001600160a01b03166116b357506000610640565b60ff8416600090815260036020526040908190205490517ff7e83aee0000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063f7e83aee9061170f9086908690600401611c95565b602060405180830381865afa15801561172c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa79190611d13565b604080518082019091526060815260006020820152825182111561177357600080fd5b83515160006117828483611c59565b905085602001518111156117a4576117a48661179f836002611d57565b611826565b8551805183820160200191600091808511156117be578482525b505050602086015b602086106117fe57805182526117dd602083611c59565b91506117ea602082611c59565b90506117f7602087611c6c565b95506117c6565b51815160001960208890036101000a0190811690199190911617905250849150509392505050565b815161183283836115f3565b5061183d838261166a565b50505050565b803560ff8116811461185457600080fd5b919050565b6001600160a01b038116811461186e57600080fd5b50565b6000806040838503121561188457600080fd5b61188d83611843565b9150602083013561189d81611859565b809150509250929050565b6000602082840312156118ba57600080fd5b813561094381611859565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156118fe576118fe6118c5565b60405290565b604051601f8201601f1916810167ffffffffffffffff8111828210171561192d5761192d6118c5565b604052919050565b600082601f83011261194657600080fd5b813567ffffffffffffffff811115611960576119606118c5565b611973601f8201601f1916602001611904565b81815284602083860101111561198857600080fd5b816020850160208301376000918101602001919091529392505050565b600082601f8301126119b657600080fd5b8135602067ffffffffffffffff808311156119d3576119d36118c5565b8260051b6119e2838201611904565b93845285810183019383810190888611156119fc57600080fd5b84880192505b85831015611a9357823584811115611a1a5760008081fd5b88016040818b03601f1901811315611a325760008081fd5b611a3a6118db565b8783013587811115611a4c5760008081fd5b611a5a8d8a83870101611935565b825250908201359086821115611a705760008081fd5b611a7e8c8984860101611935565b81890152845250509184019190840190611a02565b98975050505050505050565b60008060408385031215611ab257600080fd5b823567ffffffffffffffff811115611ac957600080fd5b611ad5858286016119a5565b95602094909401359450505050565b6000815180845260005b81811015611b0a57602081850181015186830182015201611aee565b506000602082860101526020601f19601f83011685010191505092915050565b604081526000611b3d6040830185611ae4565b905063ffffffff831660208301529392505050565b600060208284031215611b6457600080fd5b61094382611843565b6020815260006109436020830184611ae4565b600060208284031215611b9257600080fd5b813567ffffffffffffffff811115611ba957600080fd5b610aa7848285016119a5565b600181811c90821680611bc957607f821691505b602082108103611be957634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060018201611c2d57611c2d611c05565b5060010190565b604081526000611c476040830185611ae4565b905060ff831660208301529392505050565b8082018082111561094657610946611c05565b8181038181111561094657610946611c05565b634e487b7160e01b600052600160045260246000fd5b604081526000611ca86040830185611ae4565b8281036020840152611cba8185611ae4565b95945050505050565b600081611cd257611cd2611c05565b506000190190565b606081526000611ced6060830186611ae4565b8281036020840152611cff8186611ae4565b90508281036040840152610d688185611ae4565b600060208284031215611d2557600080fd5b8151801515811461094357600080fd5b600082611d5257634e487b7160e01b600052601260045260246000fd5b500690565b808202811582820484141761094657610946611c0556fea2646970667358221220e740b7c25fcb6a8d96cd167fb260ec85c1f5a0dcc05547043e12722d22c99b9a64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Constructor.",
        "params": {
          "_anchors": "The binary format RR entries for the root DS records."
        }
      },
      "setAlgorithm(uint8,address)": {
        "details": "Sets the contract address for a signature verification algorithm.      Callable only by the owner.",
        "params": {
          "algo": "The address of the algorithm contract.",
          "id": "The algorithm ID"
        }
      },
      "setDigest(uint8,address)": {
        "details": "Sets the contract address for a digest verification algorithm.      Callable only by the owner.",
        "params": {
          "digest": "The address of the digest contract.",
          "id": "The digest ID"
        }
      },
      "verifyRRSet((bytes,bytes)[])": {
        "details": "Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.",
        "params": {
          "input": "A list of signed RRSets."
        },
        "returns": {
          "inception": "The inception time of the signed record set.",
          "rrs": "The RRData from the last RRSet in the chain."
        }
      },
      "verifyRRSet((bytes,bytes)[],uint256)": {
        "details": "Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.",
        "params": {
          "input": "A list of signed RRSets.",
          "now": "The Unix timestamp to validate the records at."
        },
        "returns": {
          "inception": "The inception time of the signed record set.",
          "rrs": "The RRData from the last RRSet in the chain."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3358,
        "contract": "contracts/dnssec-oracle/DNSSECImpl.sol:DNSSECImpl",
        "label": "anchors",
        "offset": 0,
        "slot": "0",
        "type": "t_bytes_storage"
      },
      {
        "astId": 4335,
        "contract": "contracts/dnssec-oracle/DNSSECImpl.sol:DNSSECImpl",
        "label": "owner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3490,
        "contract": "contracts/dnssec-oracle/DNSSECImpl.sol:DNSSECImpl",
        "label": "algorithms",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint8,t_contract(Algorithm)5498)"
      },
      {
        "astId": 3495,
        "contract": "contracts/dnssec-oracle/DNSSECImpl.sol:DNSSECImpl",
        "label": "digests",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint8,t_contract(Digest)7339)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_contract(Algorithm)5498": {
        "encoding": "inplace",
        "label": "contract Algorithm",
        "numberOfBytes": "20"
      },
      "t_contract(Digest)7339": {
        "encoding": "inplace",
        "label": "contract Digest",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint8,t_contract(Algorithm)5498)": {
        "encoding": "mapping",
        "key": "t_uint8",
        "label": "mapping(uint8 => contract Algorithm)",
        "numberOfBytes": "32",
        "value": "t_contract(Algorithm)5498"
      },
      "t_mapping(t_uint8,t_contract(Digest)7339)": {
        "encoding": "mapping",
        "key": "t_uint8",
        "label": "mapping(uint8 => contract Digest)",
        "numberOfBytes": "32",
        "value": "t_contract(Digest)7339"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}